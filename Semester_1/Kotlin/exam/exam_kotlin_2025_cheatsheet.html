<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kotlin Exam 2025</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="cheatsheet.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Kotlin Exam 2025</h1>
</header>
<h1
id="точки-входа-в-программу.-переменные-только-для-чтения.-выведение-типа-переменной.-изменяемые-переменные.-переменные-свойства-верхнего-уровня.">1.
Точки входа в программу. Переменные только для чтения. Выведение типа
переменной. Изменяемые переменные. Переменные (свойства) верхнего
уровня.</h1>
<p>这是 <strong>Kotlin</strong> 语言的基础语法部分。虽然之前的题目是
Java，但这几个术语（尤其是“顶层属性”和 <code>val</code>/<code>var</code>
的区分）明显是 <strong>Kotlin</strong> 的特征。</p>
<p>我们将这道题拆解为 5 个小点来回答。</p>
<hr />
<h3 id="точки-входа-в-программу">1. Точки входа в программу</h3>
<p><strong>程序的入口点</strong></p>
<p>在 Kotlin 中，程序从 <code>main</code> 函数开始。与 Java
不同，它不需要放在类里面。</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Начиная с Kotlin 1.3, параметры args не обязательны.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// EN: Since Kotlin 1.3, args parameters are optional.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 从 Kotlin 1.3 开始，args 参数是可选的。</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">main</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Hello, Kotlin!&quot;</span><span class="op">)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Старый стиль (как в Java).</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 旧风格（像 Java 一样）。</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">// fun main(args: Array&lt;String&gt;) { ... }</span></span></code></pre></div>
<ul>
<li><strong>Объяснение (解释):</strong> Точка входа — это функция
<code>main</code>, определенная на верхнем уровне (вне класса). Это
аналог <code>public static void main</code> в Java, но с более
лаконичным синтаксисом. 入口点是定义在顶层（类之外）的 <code>main</code>
函数。它是 Java 中 <code>public static void main</code>
的等价物，但语法更简洁。</li>
</ul>
<hr />
<h3 id="переменные-только-для-чтения-val">2. Переменные только для
чтения (val)</h3>
<p><strong>只读变量 (val)</strong></p>
<p>这是 Kotlin 推荐的默认方式。相当于 Java 的 <code>final</code>
变量。</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Ключевое слово &#39;val&#39; (Value).</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// EN: Keyword &#39;val&#39; (Value).</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 关键字 &#39;val&#39; (Value)。</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;Gemini&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Ошибка компиляции! Переназначить нельзя.</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">// EN: Compilation Error! Cannot reassign.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 编译错误！不能重新赋值。</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">// name = &quot;GPT&quot; </span></span></code></pre></div>
<ul>
<li><strong>Объяснение (解释):</strong> Переменные, объявленные через
<code>val</code>, являются неизменяемыми (immutable reference). Их
значение присваивается один раз. 使用 <code>val</code>
声明的变量是不可变的（引用不可变）。它们的值只能被赋值一次。</li>
</ul>
<hr />
<h3 id="выведение-типа-переменной-type-inference">3. Выведение типа
переменной (Type Inference)</h3>
<p><strong>变量类型推断</strong></p>
<p>Kotlin 编译器非常聪明，通常不需要显式写出类型。</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Мы не пишем &quot;: String&quot;, компилятор сам это понял.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">// EN: We don&#39;t write &quot;: String&quot;, the compiler understood it itself.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 我们没写 &quot;: String&quot;，编译器自己看出来了。</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">message</span> <span class="op">=</span> <span class="st">&quot;Hello&quot;</span> </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Здесь тип выводится как Int.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 这里类型被推断为 Int。</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">count</span> <span class="op">=</span> <span class="dv">42</span> </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Явное указание типа (если очень нужно).</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 显式指定类型（如果非常需要）。</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">explicitDouble</span><span class="op">:</span> <span class="kw">Double</span> <span class="op">=</span> <span class="fl">3.14</span></span></code></pre></div>
<ul>
<li><strong>Объяснение (解释):</strong> Компилятор анализирует правую
часть выражения и автоматически определяет тип переменной. Это уменьшает
количество шаблонного кода.
编译器分析表达式的右侧，并自动确定变量的类型。这减少了样板代码的数量。</li>
</ul>
<hr />
<h3 id="изменяемые-переменные-var">4. Изменяемые переменные (var)</h3>
<p><strong>可变变量 (var)</strong></p>
<p>如果你需要在程序运行过程中改变变量的值，使用 <code>var</code>。</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Ключевое слово &#39;var&#39; (Variable).</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">// EN: Keyword &#39;var&#39; (Variable).</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 关键字 &#39;var&#39; (Variable)。</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> <span class="va">score</span> <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Теперь можно менять значение.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">// EN: Now we can change the value.</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 现在可以改变值了。</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>score <span class="op">=</span> <span class="dv">20</span> </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>score <span class="op">=</span> score <span class="op">+</span> <span class="dv">5</span></span></code></pre></div>
<ul>
<li><strong>Объяснение (解释):</strong> Переменные <code>var</code>
могут быть переназначены. Однако их <strong>тип</strong> изменить нельзя
(если она была Int, она останется Int). <code>var</code>
变量可以被重新赋值。但是，它们的<strong>类型</strong>不能改变（如果它是
Int，它就永远是 Int）。</li>
</ul>
<hr />
<h3 id="переменные-свойства-верхнего-уровня">5. Переменные (свойства)
верхнего уровня</h3>
<p><strong>顶层变量（属性）</strong></p>
<p>在 Java 中，一切都必须在类里。在 Kotlin
中，变量可以定义在文件级别（类之外）。</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> <span class="im">com</span><span class="op">.</span><span class="im">example</span><span class="op">.</span><span class="im">app</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Эта переменная видна во всем файле (и проекте).</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">// EN: This variable is visible in the whole file (and project).</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 这个变量在整个文件（及项目）中都可见。</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">APP_VERSION</span> <span class="op">=</span> <span class="st">&quot;1.0.0&quot;</span> </span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> <span class="va">clickCount</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> User <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">printInfo</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// RU: Можно использовать переменную верхнего уровня внутри класса.</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// CN: 可以在类内部使用顶层变量。</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Version: </span><span class="ss">$APP_VERSION</span><span class="st">&quot;</span><span class="op">)</span> </span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><strong>Объяснение (解释):</strong> Свойства верхнего уровня
объявляются вне какого-либо класса. Они заменяют статические поля
(<code>static fields</code>) из Java и доступны из любой части кода (в
зависимости от модификаторов видимости).
顶层属性是在任何类之外声明的。它们取代了 Java 中的静态字段
(<code>static fields</code>)，并且可以从代码的任何部分访问（取决于可见性修饰符）。</li>
</ul>
<h1
id="функции.-вывод-типа-значения-функции.-умалчиваемые-аргументы-функции.-именованные-аргументы-функций.-функции-с-переменным-числом-параметров.-функции-расширения.-свойства-расширения-для-чтения-и-записи.-инфиксные-функции.-функции-операторы.">2.
Функции. Вывод типа значения функции. Умалчиваемые аргументы функции.
Именованные аргументы функций. Функции с переменным числом параметров.
Функции-расширения. Свойства-расширения для чтения и записи. Инфиксные
функции. Функции-операторы.</h1>
<p>Это <strong>Kotlin</strong> (часть 2), посвященная функциям. В Kotlin
функции — это граждане первого класса, и они намного гибче, чем методы в
Java.</p>
<p>Мы разберем каждый пункт вашего вопроса с примерами кода и
пояснениями на русском и китайском языках.</p>
<hr />
<h3 id="функции-functions-и-вывод-типа-значения-type-inference">1.
Функции (Functions) и Вывод типа значения (Type Inference)</h3>
<p><strong>函数与返回值类型推断</strong></p>
<p>В Kotlin функции объявляются с помощью ключевого слова
<code>fun</code>.</p>
<p><strong>Стандартный вид (Standard):</strong></p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Блочное тело (Block Body): Тип возвращаемого значения обязателен (если не Unit).</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">// 块体：必须显式声明返回值类型（除非是 Unit）。</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">sum</span><span class="op">(</span><span class="va">a</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="va">b</span><span class="op">:</span> <span class="dt">Int</span><span class="op">):</span> <span class="dt">Int</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> a <span class="op">+</span> b</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Краткий вид с выводом типа (Single-Expression):</strong> Если
функция состоит из одного выражения, можно опустить фигурные скобки и
тип возвращаемого значения.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Компилятор сам понимает, что (Int + Int) это Int.</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 编译器自己明白 (Int + Int) 的结果是 Int。</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">sumShort</span><span class="op">(</span><span class="va">a</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="va">b</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">=</span> a <span class="op">+</span> b</span></code></pre></div>
<hr />
<h3 id="умалчиваемые-аргументы-default-arguments">2. Умалчиваемые
аргументы (Default Arguments)</h3>
<p><strong>默认参数</strong></p>
<p>Больше не нужно писать 10 перегруженных методов (Overloading), как в
Java! Можно просто задать значение по умолчанию.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Если параметр &#39;message&#39; не передан, используется &quot;Default&quot;.</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 如果没传 &#39;message&#39; 参数，就使用 &quot;Default&quot;。</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">printLog</span><span class="op">(</span><span class="va">tag</span><span class="op">:</span> <span class="dt">String</span><span class="op">,</span> <span class="va">message</span><span class="op">:</span> <span class="dt">String</span> <span class="op">=</span> <span class="st">&quot;Default&quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;</span><span class="ss">$tag</span><span class="st">: </span><span class="ss">$message</span><span class="st">&quot;</span><span class="op">)</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Использование:</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>printLog<span class="op">(</span><span class="st">&quot;System&quot;</span><span class="op">)</span> <span class="co">// Output: System: Default</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>printLog<span class="op">(</span><span class="st">&quot;User&quot;</span><span class="op">,</span> <span class="st">&quot;Hello&quot;</span><span class="op">)</span> <span class="co">// Output: User: Hello</span></span></code></pre></div>
<hr />
<h3 id="именованные-аргументы-named-arguments">3. Именованные аргументы
(Named Arguments)</h3>
<p><strong>命名参数</strong></p>
<p>Вы можете передавать аргументы в любом порядке, если указываете их
имена. Это делает код очень читаемым.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">formatText</span><span class="op">(</span><span class="va">text</span><span class="op">:</span> <span class="dt">String</span><span class="op">,</span> <span class="va">normalize</span><span class="op">:</span> <span class="dt">Boolean</span><span class="op">,</span> <span class="va">upperCase</span><span class="op">:</span> <span class="dt">Boolean</span><span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Понятно, что значит каждый boolean. Порядок не важен.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 每个 boolean 的含义一目了然。顺序不再重要。</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>formatText<span class="op">(</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    text <span class="op">=</span> <span class="st">&quot;Hello&quot;</span><span class="op">,</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    upperCase <span class="op">=</span> <span class="kw">true</span><span class="op">,</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    normalize <span class="op">=</span> <span class="kw">false</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
<hr />
<h3 id="функции-с-переменным-числом-параметров-varargs">4. Функции с
переменным числом параметров (Varargs)</h3>
<p><strong>可变参数函数</strong></p>
<p>Используется ключевое слово <code>vararg</code> (аналог
<code>...</code> в Java).</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Принимает любое количество чисел.</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 接收任意数量的数字。</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">printNumbers</span><span class="op">(</span><span class="kw">vararg</span> <span class="va">numbers</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>n <span class="kw">in</span> numbers<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span><span class="st">&quot;</span><span class="ss">$n</span><span class="st"> &quot;</span><span class="op">)</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Использование:</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>printNumbers<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">)</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Spread operator (*):</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">array</span> <span class="op">=</span> intArrayOf<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">)</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Чтобы передать массив в vararg, нужно использовать звездочку (*).</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 要把数组传给 vararg，必须使用星号 (*)。</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>printNumbers<span class="op">(*</span>array<span class="op">)</span> </span></code></pre></div>
<hr />
<h3 id="функции-расширения-extension-functions">5. Функции-расширения
(Extension Functions)</h3>
<p><strong>扩展函数</strong></p>
<p>Это “магия” Kotlin. Вы можете добавить новый метод в
<strong>существующий класс</strong> (даже в <code>String</code> или
<code>List</code>), не наследуясь от него.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Добавляем метод sayHello в класс String.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 给 String 类添加 sayHello 方法。</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">String</span><span class="op">.</span><span class="fu">sayHello</span><span class="op">():</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// &#39;this&#39; ссылается на саму строку.</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// &#39;this&#39; 指的是字符串本身。</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="st">&quot;Hello, </span><span class="ss">$this</span><span class="st">!&quot;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;World&quot;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span>name<span class="op">.</span>sayHello<span class="op">())</span> <span class="co">// Output: Hello, World!</span></span></code></pre></div>
<hr />
<h3 id="свойства-расширения-extension-properties">6. Свойства-расширения
(Extension Properties)</h3>
<p><strong>扩展属性</strong></p>
<p>Как и функции, но для свойств. Можно добавить только геттер/сеттер.
<strong>Поля (памяти) у них нет.</strong></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Добавляем свойство lastChar в String.</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 给 String 添加 lastChar 属性。</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">String</span><span class="op">.</span>lastChar<span class="op">:</span> <span class="kw">Char</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">get</span><span class="op">()</span> <span class="op">=</span> <span class="kw">this</span><span class="op">.</span><span class="kw">get</span><span class="op">(</span><span class="kw">this</span><span class="op">.</span>length <span class="op">-</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Использование:</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;Kotlin&quot;</span><span class="op">.</span>lastChar<span class="op">)</span> <span class="co">// Output: n</span></span></code></pre></div>
<ul>
<li><strong>Ограничение (Limitation):</strong> Свойства-расширения не
могут иметь <code>backing field</code> (не могут хранить состояние), они
вычисляются при каждом обращении.</li>
<li><strong>限制：</strong> 扩展属性不能有
<code>backing field</code>（不能存储状态），每次访问都会重新计算。</li>
</ul>
<hr />
<h3 id="инфиксные-функции-infix-functions">7. Инфиксные функции (Infix
Functions)</h3>
<p><strong>中缀函数</strong></p>
<p>Позволяют вызывать функцию без точки и скобок. Делает код похожим на
естественный язык.</p>
<p><strong>Требования:</strong></p>
<ol type="1">
<li>Модификатор <code>infix</code>.</li>
<li>Функция-член или расширение.</li>
<li>Ровно <strong>один</strong> параметр.</li>
</ol>
<div class="sourceCode" id="cb13"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infix</span> <span class="kw">fun</span> <span class="fu">Int</span><span class="op">.</span><span class="fu">add</span><span class="op">(</span><span class="va">x</span><span class="op">:</span> <span class="dt">Int</span><span class="op">):</span> <span class="dt">Int</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="kw">this</span> <span class="op">+</span> x</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Использование:</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Обычный вызов (Standard call)</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">a</span> <span class="op">=</span> <span class="fl">1.</span>add<span class="op">(</span><span class="dv">2</span><span class="op">)</span> </span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Инфиксный вызов (Infix call)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Выглядит как оператор!</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 看起来像操作符！</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">b</span> <span class="op">=</span> <span class="dv">1</span> add <span class="dv">2</span> </span></code></pre></div>
<hr />
<h3 id="функции-операторы-operator-functions">8. Функции-операторы
(Operator Functions)</h3>
<p><strong>操作符重载函数</strong></p>
<p>Kotlin позволяет перегружать стандартные операторы (<code>+</code>,
<code>-</code>, <code>*</code>, <code>[]</code>, <code>==</code>) с
помощью модификатора <code>operator</code>.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">class</span> Point<span class="op">(</span><span class="kw">val</span> <span class="va">x</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="kw">val</span> <span class="va">y</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Перегружаем оператор &#39;+&#39; (plus).</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 重载 &#39;+&#39; (plus) 操作符。</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">plus</span><span class="op">(</span><span class="va">other</span><span class="op">:</span> <span class="dt">Point</span><span class="op">):</span> <span class="dt">Point</span> <span class="op">{</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> Point<span class="op">(</span>x <span class="op">+</span> other<span class="op">.</span>x<span class="op">,</span> y <span class="op">+</span> other<span class="op">.</span>y<span class="op">)</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">p1</span> <span class="op">=</span> Point<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">)</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">p2</span> <span class="op">=</span> Point<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">5</span><span class="op">)</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Теперь мы можем складывать объекты через +</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 现在我们可以通过 + 来相加对象</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">p3</span> <span class="op">=</span> p1 <span class="op">+</span> p2 <span class="co">// Point(15, 25)</span></span></code></pre></div>
<p><strong>Краткий словарь операторов (Map):</strong></p>
<ul>
<li><code>plus</code> -&gt; <code>+</code></li>
<li><code>minus</code> -&gt; <code>-</code></li>
<li><code>times</code> -&gt; <code>*</code></li>
<li><code>div</code> -&gt; <code>/</code></li>
<li><code>get(i)</code> -&gt; <code>a[i]</code></li>
<li><code>invoke()</code> -&gt; <code>a()</code></li>
</ul>
<hr />
<h1
id="пакеты.-импорты.-классы.-классы-данных.-классы-перечисления.-запечатанные-классы.-объекты-одиночки-объекты-компаньены-объекты-выражения.-интерфейсы.">3.
Пакеты. Импорты. КЛАССЫ. Классы данных. Классы-перечисления.
Запечатанные классы. Объекты “Одиночки”, Объекты-компаньены,
Объекты-выражения. Интерфейсы.</h1>
<p>Это продолжение темы <strong>Kotlin</strong>, посвященное
объектно-ориентированному программированию (ООП) и структуре кода.
Kotlin значительно упрощает создание классов по сравнению с Java.</p>
<p>Мы разберем каждый пункт вашего запроса.</p>
<hr />
<h3 id="пакеты-и-импорты-packages-imports">1. Пакеты и Импорты (Packages
&amp; Imports)</h3>
<p><strong>包与导入</strong></p>
<p>В Kotlin, как и в Java, код организуется в пакеты. Однако, в отличие
от Java, <strong>структура пакетов не обязана совпадать со структурой
папок</strong>.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// В начале файла (At the top of the file)</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> <span class="im">com</span><span class="op">.</span><span class="im">example</span><span class="op">.</span><span class="im">myapp</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Импорт конкретного класса</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">// 导入特定类</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Random</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Импорт всего содержимого пакета (как *)</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co">// 导入包的所有内容</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.*</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Можно переименовать класс при импорте (устранение конфликтов имен).</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 导入时可以重命名类（解决命名冲突）。</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">sql</span><span class="op">.</span><span class="im">Date</span> <span class="kw">as</span> <span class="dt">SqlDate</span></span></code></pre></div>
<hr />
<h3 id="классы-classes">2. Классы (Classes)</h3>
<p><strong>类</strong></p>
<p>Классы в Kotlin объявляются ключевым словом <code>class</code>. По
умолчанию все классы — <strong>final</strong> (от них нельзя
наследоваться). Чтобы разрешить наследование, нужно использовать
<code>open</code>.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Первичный конструктор объявляется прямо в заголовке класса.</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 主构造器直接在类头中声明。</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Person<span class="op">(</span><span class="kw">val</span> <span class="va">name</span><span class="op">:</span> <span class="dt">String</span><span class="op">,</span> <span class="kw">var</span> <span class="va">age</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Блок инициализации (выполняется при создании).</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 初始化块（创建时执行）。</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    init <span class="op">{</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Created person: </span><span class="ss">$name</span><span class="st">&quot;</span><span class="op">)</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">sayHello</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Hi, I am </span><span class="ss">$name</span><span class="st">&quot;</span><span class="op">)</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Создание объекта (без слова new!):</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="co">// 创建对象（不需要 new 关键字！）：</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">p</span> <span class="op">=</span> Person<span class="op">(</span><span class="st">&quot;Alex&quot;</span><span class="op">,</span> <span class="dv">25</span><span class="op">)</span></span></code></pre></div>
<hr />
<h3 id="классы-данных-data-classes">3. Классы данных (Data Classes)</h3>
<p><strong>数据类</strong></p>
<p>Это аналог Java 16 <code>record</code> или Lombok <code>@Data</code>.
Используются для хранения данных.</p>
<p><strong>Kotlin автоматически генерирует:</strong></p>
<ul>
<li><code>toString()</code></li>
<li><code>equals()</code> / <code>hashCode()</code></li>
<li><code>copy()</code></li>
<li><code>componentN()</code> (для деструктуризации)</li>
</ul>
<div class="sourceCode" id="cb17"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Ключевое слово &#39;data&#39;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">class</span> User<span class="op">(</span><span class="kw">val</span> <span class="va">name</span><span class="op">:</span> <span class="dt">String</span><span class="op">,</span> <span class="kw">val</span> <span class="va">id</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> <span class="va">u1</span> <span class="op">=</span> User<span class="op">(</span><span class="st">&quot;Alice&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> <span class="va">u2</span> <span class="op">=</span> User<span class="op">(</span><span class="st">&quot;Alice&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Автоматический toString()</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span>u1<span class="op">)</span> <span class="co">// User(name=Alice, id=1)</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Сравнение по содержимому (equals), а не по ссылкам.</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 按内容比较 (equals)，而不是按引用。</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span>u1 <span class="op">==</span> u2<span class="op">)</span> <span class="co">// true</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Метод copy() для создания копии с изменением полей.</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: copy() 方法用于创建副本并修改字段。</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> <span class="va">u3</span> <span class="op">=</span> u1<span class="op">.</span>copy<span class="op">(</span>id <span class="op">=</span> <span class="dv">2</span><span class="op">)</span> </span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="классы-перечисления-enum-classes">4. Классы-перечисления (Enum
Classes)</h3>
<p><strong>枚举类</strong></p>
<p>Почти как в Java, но ключевых слова два: <code>enum class</code>.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> Status<span class="op">(</span><span class="kw">val</span> <span class="va">code</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    OPEN<span class="op">(</span><span class="dv">100</span><span class="op">),</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    IN_PROGRESS<span class="op">(</span><span class="dv">102</span><span class="op">),</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    CLOSED<span class="op">(</span><span class="dv">200</span><span class="op">);</span> <span class="co">// Точка с запятой обязательна, если дальше идут методы.</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">isFinished</span><span class="op">():</span> <span class="dt">Boolean</span> <span class="op">=</span> <span class="kw">this</span> <span class="op">==</span> CLOSED</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="запечатанные-классы-sealed-classes">5. Запечатанные классы
(Sealed Classes)</h3>
<p><strong>密封类</strong></p>
<p>Это “супер-энумы”. Они ограничивают иерархию наследования. Все
наследники должны быть известны компилятору. Идеально подходят для
обработки состояний (State) в архитектуре (например, MVI/MVVM).</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Наследоваться могут только классы в этом же файле/пакете.</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 只有同一个文件/包中的类可以继承它。</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">sealed</span> <span class="kw">class</span> Result</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Наследники могут быть data class или object</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">class</span> Success<span class="op">(</span><span class="kw">val</span> <span class="kw">data</span><span class="op">:</span> <span class="dt">String</span><span class="op">)</span> <span class="op">:</span> <span class="dt">Result</span><span class="op">()</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">class</span> Error<span class="op">(</span><span class="kw">val</span> <span class="va">exception</span><span class="op">:</span> <span class="dt">Exception</span><span class="op">)</span> <span class="op">:</span> <span class="dt">Result</span><span class="op">()</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> Loading <span class="op">:</span> <span class="dt">Result</span><span class="op">()</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">handleResult</span><span class="op">(</span><span class="va">result</span><span class="op">:</span> <span class="dt">Result</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: В &#39;when&#39; не нужна ветка &#39;else&#39;, так как компилятор знает все варианты.</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: &#39;when&#39; 中不需要 &#39;else&#39; 分支，因为编译器知道所有选项。</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">when</span> <span class="op">(</span>result<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">is</span> Success <span class="op">-&gt;</span> println<span class="op">(</span>result<span class="op">.</span><span class="kw">data</span><span class="op">)</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">is</span> Error <span class="op">-&gt;</span> println<span class="op">(</span>result<span class="op">.</span>exception<span class="op">)</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        Loading <span class="op">-&gt;</span> println<span class="op">(</span><span class="st">&quot;Loading...&quot;</span><span class="op">)</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="объекты-objects">6. Объекты (Objects)</h3>
<p>В Kotlin ключевое слово <code>object</code> используется в трех
разных ситуациях.</p>
<h4 id="a.-объекты-одиночки-object-declaration">A. Объекты “Одиночки”
(Object Declaration)</h4>
<p><strong>单例对象 (Singleton)</strong> Это реализация паттерна
Singleton “из коробки”.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Этот объект существует в единственном экземпляре.</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 这个对象只有一个实例。</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> DatabaseConfig <span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> <span class="va">url</span> <span class="op">=</span> <span class="st">&quot;jdbc:mysql://localhost&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">connect</span><span class="op">()</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Использование:</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>DatabaseConfig<span class="op">.</span>connect<span class="op">()</span></span></code></pre></div>
<h4 id="b.-объекты-компаньоны-companion-objects">B. Объекты-компаньоны
(Companion Objects)</h4>
<p><strong>伴生对象</strong> В Kotlin <strong>нет</strong> ключевого
слова <code>static</code>. Вместо статических методов используется
<code>companion object</code>.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyClass <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Обычный метод</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">method</span><span class="op">()</span> <span class="op">{}</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Компаньон. Его методы вызываются через имя класса.</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 伴生对象。其方法通过类名调用。</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">companion</span> <span class="kw">object</span> <span class="op">{</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fun</span> <span class="fu">staticMethod</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>            println<span class="op">(</span><span class="st">&quot;I am like static&quot;</span><span class="op">)</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Вызов:</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>MyClass<span class="op">.</span>staticMethod<span class="op">()</span></span></code></pre></div>
<h4 id="c.-объекты-выражения-object-expressions">C. Объекты-выражения
(Object Expressions)</h4>
<p><strong>对象表达式 (匿名类)</strong> Замена анонимным классам в Java.
Используется, когда нужно создать объект интерфейса “на лету”.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> ClickListener <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">onClick</span><span class="op">()</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">setListener</span><span class="op">(</span><span class="va">listener</span><span class="op">:</span> <span class="dt">ClickListener</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">main</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Создаем анонимный объект.</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 创建匿名对象。</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    setListener<span class="op">(</span><span class="kw">object</span> <span class="op">:</span> <span class="dt">ClickListener</span> <span class="op">{</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">onClick</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>            println<span class="op">(</span><span class="st">&quot;Clicked!&quot;</span><span class="op">)</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="интерфейсы-interfaces">7. Интерфейсы (Interfaces)</h3>
<p><strong>接口</strong></p>
<p>Интерфейсы в Kotlin могут содержать не только абстрактные методы, но
и <strong>реализацию по умолчанию</strong>, а также <strong>абстрактные
свойства</strong>.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Movable <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Абстрактное свойство (наследник должен переопределить геттер)</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> <span class="va">speed</span><span class="op">:</span> <span class="kw">Int</span> </span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Абстрактный метод</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">move</span><span class="op">()</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Метод с реализацией по умолчанию</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 带有默认实现的方法</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">stop</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Stopped&quot;</span><span class="op">)</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Car<span class="op">(</span><span class="kw">override</span> <span class="kw">val</span> <span class="va">speed</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">:</span> <span class="dt">Movable</span> <span class="op">{</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">move</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Moving at </span><span class="ss">$speed</span><span class="st"> km/h&quot;</span><span class="op">)</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1
id="циклы-оператор-in.-диапазоны-ranges.-использование-числовых-диапазонов-в-циклах.-использование-диапазонов-в-условном-выражении.-выбирающее-предложение-when.-условное-выражение-if.-исключения.-порождение-исключения.-перехват-исключения.-исключения-как-выражения.">4.
Циклы, Оператор in. Диапазоны (ranges). Использование числовых
диапазонов в циклах. Использование диапазонов в условном выражении.
Выбирающее предложение when. Условное выражение if. ИСКЛЮЧЕНИЯ.
Порождение исключения. Перехват исключения. Исключения как
выражения.</h1>
<p>Это продолжение темы <strong>Kotlin</strong>, посвященное управлению
потоком выполнения (Control Flow) и обработке ошибок. 这是
<strong>Kotlin</strong> 的延续，主要讲解控制流 (Control Flow)
和错误处理。</p>
<p>Мы разберем каждый пункт строго по порядку.
我们将严格按照顺序解析每一点。</p>
<hr />
<h3 id="циклы-loops">1. Циклы (Loops)</h3>
<p><strong>循环</strong></p>
<p>В Kotlin основными циклами являются <code>for</code>,
<code>while</code> и <code>do-while</code>. Kotlin 中的主要循环是
<code>for</code>、<code>while</code> 和 <code>do-while</code>。</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 1. Цикл for (перебор элементов)</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co">// 1. for 循环（遍历元素）</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="st">&quot;B&quot;</span><span class="op">,</span> <span class="st">&quot;C&quot;</span><span class="op">)</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>item <span class="kw">in</span> list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span>item<span class="op">)</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="co">// 2. Цикл while (пока условие истинно)</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="co">// 2. while 循环（当条件为真时）</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> <span class="va">x</span> <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>x <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    x<span class="op">--</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="оператор-in">2. Оператор in</h3>
<p><strong><code>in</code> 操作符</strong></p>
<p>Оператор <code>in</code> используется для проверки вхождения элемента
в коллекцию или диапазон, а также для итерации. <code>in</code>
操作符用于检查元素是否属于集合或范围，也用于迭代。</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">names</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;Ivan&quot;</span><span class="op">,</span> <span class="st">&quot;Maria&quot;</span><span class="op">)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Проверка: есть ли &quot;Ivan&quot; в списке?</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 检查：&quot;Ivan&quot; 在列表中吗？</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="st">&quot;Ivan&quot;</span> <span class="kw">in</span> names<span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Found!&quot;</span><span class="op">)</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Итерация: для каждого элемента В списке.</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 迭代：对于列表中的每个元素。</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>name <span class="kw">in</span> names<span class="op">)</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="диапазоны-ranges">3. Диапазоны (Ranges)</h3>
<p><strong>范围</strong></p>
<p>Диапазоны позволяют легко создавать последовательности чисел.
范围允许轻松创建数字序列。</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Диапазон от 1 до 10 (включительно).</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 从 1 到 10 的范围（包含 10）。</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">oneToTen</span> <span class="op">=</span> <span class="fl">1..10</span> </span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Диапазон от 1 до 9 (10 не включается).</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 从 1 到 9 的范围（不包含 10）。</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">oneToNine</span> <span class="op">=</span> <span class="dv">1</span> until <span class="dv">10</span></span></code></pre></div>
<hr />
<h3 id="использование-числовых-диапазонов-в-циклах">4. Использование
числовых диапазонов в циклах</h3>
<p><strong>在循环中使用数字范围</strong></p>
<p>Мы можем использовать диапазоны напрямую в цикле <code>for</code>.
我们可以直接在 <code>for</code> 循环中使用范围。</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Простой перебор: 1, 2, 3, 4, 5.</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 简单遍历：1, 2, 3, 4, 5。</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="kw">in</span> <span class="fl">1..5</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span>i<span class="op">)</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Обратный отсчет: 5, 4, 3, 2, 1.</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 倒数：5, 4, 3, 2, 1。</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="kw">in</span> <span class="dv">5</span> downTo <span class="dv">1</span><span class="op">)</span> <span class="op">{</span> </span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span>i<span class="op">)</span> </span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: С шагом: 1, 3, 5, 7...</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 带步长：1, 3, 5, 7...</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="kw">in</span> <span class="fl">1..10</span> step <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span>i<span class="op">)</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="использование-диапазонов-в-условном-выражении">5. Использование
диапазонов в условном выражении</h3>
<p><strong>在条件表达式中使用范围</strong></p>
<p>Очень удобно проверять, попадает ли число в заданный интервал.
检查数字是否落在给定区间内非常方便。</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">age</span> <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Если возраст от 18 до 60 (включительно).</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 如果年龄在 18 到 60 岁之间（含）。</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>age <span class="kw">in</span> <span class="fl">18..60</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Worker&quot;</span><span class="op">)</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Проверка &quot;НЕ входит&quot;.</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 检查 &quot;不属于&quot;。</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>age <span class="op">!</span><span class="kw">in</span> <span class="fl">0..100</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Invalid age&quot;</span><span class="op">)</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="выбирающее-предложение-when">6. Выбирающее предложение when</h3>
<p><strong><code>when</code> 选择语句</strong></p>
<p><code>when</code> — это мощная замена оператору <code>switch</code>
из Java/C++. Он может возвращать значение. <code>when</code> 是 Java/C++
中 <code>switch</code> 操作符的强大替代品。它可以返回值。</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">x</span> <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: when как выражение (возвращает String).</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: when 作为表达式（返回 String）。</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">result</span> <span class="op">=</span> <span class="cf">when</span> <span class="op">(</span>x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span> <span class="op">-&gt;</span> <span class="st">&quot;One&quot;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span> <span class="op">-&gt;</span> <span class="st">&quot;Two or Three&quot;</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> <span class="fl">10..20</span> <span class="op">-&gt;</span> <span class="st">&quot;Between 10 and 20&quot;</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">-&gt;</span> <span class="st">&quot;Unknown&quot;</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="условное-выражение-if">7. Условное выражение if</h3>
<p><strong><code>if</code> 条件表达式</strong></p>
<p>В Kotlin <code>if</code> — это выражение (expression), оно возвращает
значение. Тернарного оператора (<code>? :</code>) в Kotlin нет, потому
что <code>if</code> выполняет его роль. 在 Kotlin 中，<code>if</code>
是一个表达式 (expression)，它会返回值。Kotlin 中没有三元运算符
(<code>? :</code>)，因为 <code>if</code> 扮演了这个角色。</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">a</span> <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">b</span> <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Вместо: int max = (a &gt; b) ? a : b;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 代替：int max = (a &gt; b) ? a : b;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">max</span> <span class="op">=</span> <span class="cf">if</span> <span class="op">(</span>a <span class="op">&gt;</span> b<span class="op">)</span> a <span class="cf">else</span> b</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Можно использовать блоки кода (возвращается последняя строка).</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 可以使用代码块（返回最后一行）。</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">min</span> <span class="op">=</span> <span class="cf">if</span> <span class="op">(</span>a <span class="op">&lt;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;a is smaller&quot;</span><span class="op">)</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    a <span class="co">// Return value</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    b <span class="co">// Return value</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="исключения-exceptions">8. ИСКЛЮЧЕНИЯ (Exceptions)</h3>
<p><strong>异常</strong></p>
<p>Все классы исключений в Kotlin наследуются от <code>Throwable</code>.
В Kotlin нет “проверяемых исключений” (Checked Exceptions). Вам не нужно
писать <code>throws IOException</code>. Kotlin 中的所有异常类都继承自
<code>Throwable</code>。Kotlin 中没有“受检异常” (Checked
Exceptions)。你不需要写 <code>throws IOException</code>。</p>
<hr />
<h3 id="порождение-исключения">9. Порождение исключения</h3>
<p><strong>抛出异常</strong></p>
<p>Используется ключевое слово <code>throw</code>. 使用
<code>throw</code> 关键字。</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">validate</span><span class="op">(</span><span class="va">age</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>age <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// RU: Бросаем исключение.</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// CN: 抛出异常。</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">throw</span> IllegalArgumentException<span class="op">(</span><span class="st">&quot;Age cannot be negative&quot;</span><span class="op">)</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="перехват-исключения">10. Перехват исключения</h3>
<p><strong>捕获异常</strong></p>
<p>Используется стандартная конструкция <code>try-catch-finally</code>.
使用标准的 <code>try-catch-finally</code> 结构。</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Code that may fail</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    validate<span class="op">(-</span><span class="dv">5</span><span class="op">)</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>e<span class="op">:</span> IllegalArgumentException<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Обработка ошибки.</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 错误处理。</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Error: </span><span class="ss">${</span>e<span class="op">.</span>message<span class="ss">}</span><span class="st">&quot;</span><span class="op">)</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">finally</span> <span class="op">{</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Выполняется всегда.</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 总是执行。</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Done&quot;</span><span class="op">)</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="исключения-как-выражения">11. Исключения как выражения</h3>
<p><strong>异常作为表达式</strong></p>
<p>В Kotlin <code>try</code> — это тоже выражение! Оно может возвращать
результат. 在 Kotlin 中，<code>try</code>
也是一个表达式！它可以返回结果。</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">input</span> <span class="op">=</span> <span class="st">&quot;123a&quot;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Пытаемся распарсить число. Если ошибка — возвращаем null (или 0).</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 尝试解析数字。如果出错 — 返回 null（或 0）。</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">number</span><span class="op">:</span> <span class="kw">Int</span><span class="op">?</span> <span class="op">=</span> <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    input<span class="op">.</span>toInt<span class="op">()</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span>e<span class="op">:</span> NumberFormatException<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">null</span> <span class="co">// RU: Это значение пойдет в переменную number. (CN: 这个值将赋给变量 number。)</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span>number<span class="op">)</span> <span class="co">// Output: null</span></span></code></pre></div>
<h1
id="перегрузка-операторов.-унарные-префиксные-операторы.-арифметические-операции.-операторы-сравнений.-оператор-in.-оператор-доступа-по-индексу.-оператор-вызова.-присвоения-с-накоплением.">5.
Перегрузка операторов. Унарные префиксные операторы. Арифметические
операции. Операторы сравнений. Оператор in. Оператор доступа по индексу.
Оператор вызова. Присвоения с накоплением.</h1>
<p>Это <strong>5-й вопрос (Question 5)</strong> из вашего списка по
Kotlin. 这是您列表中的 <strong>第 5 题 (Question 5)</strong>，关于
Kotlin 的操作符重载。</p>
<p>В Kotlin перегрузка операторов — это возможность задать свою
реализацию для стандартных знаков (<code>+</code>, <code>-</code>,
<code>*</code>, <code>/</code> и т.д.) с помощью ключевого слова
<code>operator</code> и специальных имен функций. 在 Kotlin
中，操作符重载允许你通过关键字 <code>operator</code>
和特定的函数名为标准符号（<code>+</code>, <code>-</code>,
<code>*</code>, <code>/</code> 等）定义自己的实现。</p>
<p>Мы разберем каждый пункт подробно. 我们将逐一详细解析。</p>
<hr />
<h3 id="перегрузка-операторов-operator-overloading">1. Перегрузка
операторов (Operator Overloading)</h3>
<p><strong>操作符重载</strong></p>
<p>Для перегрузки оператора нужно объявить функцию с ключевым словом
<code>operator</code> и зарезервированным именем (например,
<code>plus</code> для <code>+</code>). 要重载操作符，需要声明一个带有
<code>operator</code> 关键字和保留名称（例如 <code>plus</code> 对应
<code>+</code>）的函数。</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">class</span> Point<span class="op">(</span><span class="kw">val</span> <span class="va">x</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="kw">val</span> <span class="va">y</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Объявляем оператор.</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 声明操作符。</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">plus</span><span class="op">(</span><span class="va">other</span><span class="op">:</span> <span class="dt">Point</span><span class="op">):</span> <span class="dt">Point</span> <span class="op">{</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> Point<span class="op">(</span>x <span class="op">+</span> other<span class="op">.</span>x<span class="op">,</span> y <span class="op">+</span> other<span class="op">.</span>y<span class="op">)</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="унарные-префиксные-операторы">2. Унарные префиксные
операторы</h3>
<p><strong>一元前缀操作符</strong></p>
<p>Эти операторы применяются к одной переменной (<code>-a</code>,
<code>!a</code>, <code>++a</code>). 这些操作符作用于单个变量
(<code>-a</code>, <code>!a</code>, <code>++a</code>)。</p>
<p><strong>Таблица имен (Name Table):</strong></p>
<ul>
<li><code>+a</code> -&gt; <code>unaryPlus()</code></li>
<li><code>-a</code> -&gt; <code>unaryMinus()</code></li>
<li><code>!a</code> -&gt; <code>not()</code></li>
<li><code>++a</code> -&gt; <code>inc()</code> (Increment / 自增)</li>
<li><code>--a</code> -&gt; <code>dec()</code> (Decrement / 自减)</li>
</ul>
<div class="sourceCode" id="cb35"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">class</span> Counter<span class="op">(</span><span class="kw">val</span> <span class="va">value</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Перегрузка унарного минуса (-a).</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 重载一元负号 (-a)。</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">unaryMinus</span><span class="op">():</span> <span class="dt">Counter</span> <span class="op">{</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> Counter<span class="op">(-</span>value<span class="op">)</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">c</span> <span class="op">=</span> Counter<span class="op">(</span><span class="dv">10</span><span class="op">)</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">negative</span> <span class="op">=</span> <span class="op">-</span>c <span class="co">// Counter(-10)</span></span></code></pre></div>
<hr />
<h3 id="арифметические-операции">3. Арифметические операции</h3>
<p><strong>算术运算</strong></p>
<p>Это стандартные бинарные операции (<code>a + b</code>).
这是标准的二元运算 (<code>a + b</code>)。</p>
<p><strong>Таблица имен (Name Table):</strong></p>
<ul>
<li><code>a + b</code> -&gt; <code>plus</code></li>
<li><code>a - b</code> -&gt; <code>minus</code></li>
<li><code>a * b</code> -&gt; <code>times</code></li>
<li><code>a / b</code> -&gt; <code>div</code></li>
<li><code>a % b</code> -&gt; <code>rem</code> (остаток / 取余)</li>
</ul>
<div class="sourceCode" id="cb36"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Пример умножения (times).</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 乘法示例 (times)。</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">times</span><span class="op">(</span><span class="va">scale</span><span class="op">:</span> <span class="dt">Int</span><span class="op">):</span> <span class="dt">Point</span> <span class="op">{</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> Point<span class="op">(</span>x <span class="op">*</span> scale<span class="op">,</span> y <span class="op">*</span> scale<span class="op">)</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="операторы-сравнений">4. Операторы сравнений</h3>
<p><strong>比较操作符</strong></p>
<p>В Kotlin операторы сравнения (<code>&gt;</code>, <code>&lt;</code>,
<code>&gt;=</code>, <code>&lt;=</code>) преобразуются в вызов функции
<code>compareTo</code>. 在 Kotlin 中，比较操作符 (<code>&gt;</code>,
<code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>) 会被转换为对
<code>compareTo</code> 函数的调用。</p>
<p><strong>Правило (Rule):</strong></p>
<ul>
<li><code>a &gt; b</code> превращается в
<code>a.compareTo(b) &gt; 0</code></li>
<li><code>a &lt; b</code> превращается в
<code>a.compareTo(b) &lt; 0</code></li>
</ul>
<div class="sourceCode" id="cb37"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Person<span class="op">(</span><span class="kw">val</span> <span class="va">age</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">:</span> <span class="dt">Comparable</span><span class="op">&lt;</span><span class="dt">Person</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Функция должна возвращать Int (отрицательное, ноль или положительное число).</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 该函数必须返回 Int（负数、零或正数）。</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">compareTo</span><span class="op">(</span><span class="va">other</span><span class="op">:</span> <span class="dt">Person</span><span class="op">):</span> <span class="dt">Int</span> <span class="op">{</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="kw">this</span><span class="op">.</span>age <span class="op">-</span> other<span class="op">.</span>age</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">p1</span> <span class="op">=</span> Person<span class="op">(</span><span class="dv">20</span><span class="op">)</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">p2</span> <span class="op">=</span> Person<span class="op">(</span><span class="dv">30</span><span class="op">)</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">result</span> <span class="op">=</span> p1 <span class="op">&lt;</span> p2 <span class="co">// true</span></span></code></pre></div>
<ul>
<li><strong>Примечание:</strong> <code>==</code> преобразуется в
<code>equals()</code>, но <code>equals</code> не требует ключевого слова
<code>operator</code> (это переопределение из <code>Any</code>).</li>
<li><strong>注意：</strong> <code>==</code> 转换为
<code>equals()</code>，但 <code>equals</code> 不需要
<code>operator</code> 关键字（它是对 <code>Any</code> 的重写）。</li>
</ul>
<hr />
<h3 id="оператор-in-1">5. Оператор in</h3>
<p><strong><code>in</code> 操作符</strong></p>
<p>Используется для проверки вхождения элемента в коллекцию
(<code>a in b</code>). Преобразуется в функцию <code>contains</code>.
用于检查元素是否包含在集合中 (<code>a in b</code>)。转换为
<code>contains</code> 函数。</p>
<p><strong>Таблица имен (Name Table):</strong></p>
<ul>
<li><code>a in b</code> -&gt; <code>b.contains(a)</code></li>
<li><code>a !in b</code> -&gt; <code>!b.contains(a)</code></li>
</ul>
<div class="sourceCode" id="cb38"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">class</span> Rectangle<span class="op">(</span><span class="kw">val</span> <span class="va">left</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="kw">val</span> <span class="va">right</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Проверяем, находится ли точка внутри границ.</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 检查点是否在边界内。</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">contains</span><span class="op">(</span><span class="va">x</span><span class="op">:</span> <span class="dt">Int</span><span class="op">):</span> <span class="dt">Boolean</span> <span class="op">{</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> x <span class="kw">in</span> left<span class="op">..</span>right</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">rect</span> <span class="op">=</span> Rectangle<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Вызовется rect.contains(5).</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 将调用 rect.contains(5)。</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">isInside</span> <span class="op">=</span> <span class="dv">5</span> <span class="kw">in</span> rect <span class="co">// true</span></span></code></pre></div>
<hr />
<h3 id="оператор-доступа-по-индексу">6. Оператор доступа по индексу</h3>
<p><strong>索引访问操作符</strong></p>
<p>Позволяет обращаться к объекту как к массиву или списку через
квадратные скобки <code>[]</code>. 允许像数组或列表一样通过方括号
<code>[]</code> 访问对象。</p>
<p><strong>Таблица имен (Name Table):</strong></p>
<ul>
<li><code>a[i]</code> (чтение / 读) -&gt; <code>get(i)</code></li>
<li><code>a[i] = b</code> (запись / 写) -&gt;
<code>set(i, b)</code></li>
</ul>
<div class="sourceCode" id="cb39"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Matrix <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Чтение a[i, j].</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 读取 a[i, j]。</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="kw">fun</span> <span class="kw">get</span><span class="op">(</span><span class="va">row</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="va">col</span><span class="op">:</span> <span class="dt">Int</span><span class="op">):</span> <span class="dt">Int</span> <span class="op">{</span> <span class="kw">return</span> <span class="dv">0</span> <span class="op">}</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Запись a[i, j] = value.</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 写入 a[i, j] = value。</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="kw">fun</span> <span class="kw">set</span><span class="op">(</span><span class="va">row</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="va">col</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="va">value</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">m</span> <span class="op">=</span> Matrix<span class="op">()</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>m<span class="op">[</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">5</span> <span class="co">// set(1, 2, 5)</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">x</span> <span class="op">=</span> m<span class="op">[</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">]</span> <span class="co">// get(1, 2)</span></span></code></pre></div>
<hr />
<h3 id="оператор-вызова-invoke">7. Оператор вызова (Invoke)</h3>
<p><strong>调用操作符</strong></p>
<p>Позволяет вызывать объект, как будто это функция.
允许像调用函数一样调用对象。</p>
<p><strong>Таблица имен (Name Table):</strong></p>
<ul>
<li><code>a()</code> -&gt; <code>a.invoke()</code></li>
<li><code>a(i)</code> -&gt; <code>a.invoke(i)</code></li>
</ul>
<div class="sourceCode" id="cb40"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Greeter <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Оператор invoke.</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: invoke 操作符。</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">invoke</span><span class="op">(</span><span class="va">name</span><span class="op">:</span> <span class="dt">String</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Hello, </span><span class="ss">$name</span><span class="st">!&quot;</span><span class="op">)</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">greet</span> <span class="op">=</span> Greeter<span class="op">()</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Вызываем объект как функцию!</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 像函数一样调用对象！</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>greet<span class="op">(</span><span class="st">&quot;Kotlin&quot;</span><span class="op">)</span> </span></code></pre></div>
<hr />
<h3 id="присвоения-с-накоплением-augmented-assignments">8. Присвоения с
накоплением (Augmented Assignments)</h3>
<p><strong>累加赋值 (复合赋值)</strong></p>
<p>Это операторы типа <code>+=</code>, <code>-=</code>, <code>*=</code>.
这是 <code>+=</code>, <code>-=</code>, <code>*=</code>
类型的操作符。</p>
<p><strong>Логика (Logic):</strong></p>
<ol type="1">
<li>Если определена функция <code>plusAssign</code>, используется она
(изменяет объект, <code>void</code>).</li>
<li>Если нет, используется <code>plus</code> (создает новый объект:
<code>a = a + b</code>).</li>
<li>如果定义了 <code>plusAssign</code> 函数，则使用它（修改对象，返回
<code>void</code>）。</li>
<li>如果没有，则使用
<code>plus</code>（创建新对象：<code>a = a + b</code>）。</li>
</ol>
<div class="sourceCode" id="cb41"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">class</span> Box<span class="op">(</span><span class="kw">var</span> <span class="va">items</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Изменяем текущий объект.</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 修改当前对象。</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">plusAssign</span><span class="op">(</span><span class="va">other</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">.</span>items <span class="op">+=</span> other</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">box</span> <span class="op">=</span> Box<span class="op">(</span><span class="dv">5</span><span class="op">)</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>box <span class="op">+=</span> <span class="dv">3</span> <span class="co">// items = 8</span></span></code></pre></div>
<h1
id="объявление-интерфейсов.-наследование-интерфейсов.-реализация-интерфейсов.-реализация-свойств-интерфейсов.">6.
Объявление интерфейсов. Наследование интерфейсов. Реализация
интерфейсов. Реализация свойств интерфейсов.</h1>
<h1
id="модификаторы-класса-abstract-open-final-sealed.-модификаторы-видимости-public-internal-protected-private.-основной-и-вторичные-конструкторы-класса.-свойства-класса-реализация-свойств-интерфейсов.-свойства-с-поздней-инициализацией.-внутренние-и-вложенные-классы.-универсальные-методы-классов.">7.
Модификаторы класса abstract open final sealed. Модификаторы видимости
public, internal, protected, private. Основной и вторичные конструкторы
класса. Свойства класса, реализация свойств интерфейсов. Свойства с
поздней инициализацией. Внутренние и вложенные классы. Универсальные
методы классов.</h1>
<p>Это <strong>6-й вопрос (Question 6)</strong>, посвященный интерфейсам
в Kotlin. 这是 <strong>第 6 题 (Question 6)</strong>，关于 Kotlin
中的接口。</p>
<p>В Kotlin интерфейсы очень похожи на Java 8+, так как они могут
содержать реализацию методов по умолчанию и абстрактные свойства. 在
Kotlin 中，接口非常类似于 Java
8+，因为它们可以包含默认方法实现和抽象属性。</p>
<hr />
<h3 id="объявление-интерфейсов">1. Объявление интерфейсов</h3>
<p><strong>接口声明</strong></p>
<p>Для создания интерфейса используется ключевое слово
<code>interface</code>. Методы могут быть абстрактными (без тела) или
иметь реализацию по умолчанию. 使用关键字 <code>interface</code>
创建接口。方法可以是抽象的（没有方法体），也可以有默认实现。</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Объявление интерфейса.</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 声明接口。</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Clickable <span class="op">{</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Абстрактный метод (нужно реализовать).</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 抽象方法（必须实现）。</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">click</span><span class="op">()</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Метод с реализацией по умолчанию (не обязательно переопределять).</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 带有默认实现的方法（不强制重写）。</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">show</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;I am clickable!&quot;</span><span class="op">)</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="наследование-интерфейсов">2. Наследование интерфейсов</h3>
<p><strong>接口继承</strong></p>
<p>Один интерфейс может наследовать другой. В этом случае наследуемый
интерфейс может переопределить методы родителя или оставить их как есть.
一个接口可以继承另一个接口。在这种情况下，继承的接口可以重写父类的方法，也可以保持原样。</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Интерфейс Resizable наследует Clickable.</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 接口 Resizable 继承 Clickable。</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Resizable <span class="op">:</span> <span class="dt">Clickable</span> <span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">resize</span><span class="op">()</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<hr />
<h3 id="реализация-интерфейсов">3. Реализация интерфейсов</h3>
<p><strong>接口实现</strong></p>
<p>Класс или объект реализует интерфейс, используя двоеточие
<code>:</code>. Все абстрактные члены должны быть переопределены с
помощью <code>override</code>. 类或对象使用冒号 <code>:</code>
实现接口。必须使用 <code>override</code> 重写所有抽象成员。</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Класс Button реализует Clickable.</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: Button 类实现 Clickable。</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Button <span class="op">:</span> <span class="dt">Clickable</span> <span class="op">{</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Обязательная реализация.</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 必须实现。</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">click</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Button clicked&quot;</span><span class="op">)</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Метод show() можно не переопределять, возьмется версия из интерфейса.</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: show() 方法可以不重写，会使用接口中的版本。</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="реализация-свойств-интерфейсов">4. Реализация свойств
интерфейсов</h3>
<p><strong>接口属性的实现</strong></p>
<p>Это уникальная особенность Kotlin. Интерфейсы могут содержать
свойства, но они <strong>не могут хранить состояние</strong> (у них нет
<code>backing field</code>). 这是 Kotlin
的独特功能。接口可以包含属性，但它们<strong>不能存储状态</strong>（没有
<code>backing field</code>，即幕后字段）。</p>
<p><strong>Варианта два (Two options):</strong></p>
<ol type="1">
<li><strong>Абстрактное свойство (Abstract):</strong> Класс должен
предоставить значение.</li>
<li><strong>Свойство с геттером (With Accessor):</strong> Вычисляет
значение каждый раз.</li>
</ol>
<div class="sourceCode" id="cb45"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> User <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Абстрактное свойство. Класс-наследник должен хранить эти данные.</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 抽象属性。子类必须存储此数据。</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> <span class="va">email</span><span class="op">:</span> <span class="kw">String</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Свойство с геттером. Оно не занимает память, а вычисляется на лету.</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 带 getter 的属性。它不占用内存，而是即时计算。</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> <span class="va">nickname</span><span class="op">:</span> <span class="kw">String</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">get</span><span class="op">()</span> <span class="op">=</span> email<span class="op">.</span>substringBefore<span class="op">(</span><span class="ch">&#39;@&#39;</span><span class="op">)</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PrivateUser<span class="op">(</span><span class="kw">override</span> <span class="kw">val</span> <span class="va">email</span><span class="op">:</span> <span class="dt">String</span><span class="op">)</span> <span class="op">:</span> <span class="dt">User</span> <span class="op">{</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: nickname вычисляется автоматически на основе email.</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: nickname 根据 email 自动计算。</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1
id="иерархия-типов-языка-kotlin.-поддержка-значения-null.-оператор-безопасного-вызова-.-оператор-элвис-проверка-на-null-c-помощью-оператора-безопасное-приведение-типов-оператор-as-функция-let.-свойства-с-отложенной-инициализацией.-расширение-типов-поддерживающих-значение-null.-типы-и-подтипы-классы-и-подклассы.-изменяемые-и-неизменяемые-коллекции.">8.
Иерархия типов языка Kotlin. Поддержка значения null. Оператор
безопасного вызова ?. Оператор Элвис ?: Проверка на null c помощью
оператора !! Безопасное приведение типов: оператор as? Функция let.
Свойства с отложенной инициализацией. Расширение типов поддерживающих
значение null. Типы и подтипы, классы и подклассы. Изменяемые и
неизменяемые коллекции.</h1>
<p>Это <strong>7-й вопрос (Question 7)</strong>, охватывающий систему
типов Kotlin и безопасность Null (Null Safety). 这是 <strong>第 7 题
(Question 7)</strong>，涵盖了 Kotlin 的类型系统和空安全 (Null
Safety)。</p>
<p>Мы разберем каждое предложение как отдельный вопрос.
我们将把每一句话作为一个单独的问题来解析。</p>
<hr />
<h3 id="иерархия-типов-языка-kotlin">1. Иерархия типов языка Kotlin</h3>
<p><strong>Kotlin 语言的类型层次结构</strong></p>
<p>В Kotlin вершиной иерархии является класс <code>Any</code>. 在 Kotlin
中，类型层次结构的顶端是 <code>Any</code> 类。</p>
<ul>
<li><p><strong>Any:</strong> Корень всех <strong>не-null</strong> типов
(аналог <code>Object</code> в Java).</p></li>
<li><p><strong>Any:</strong> 所有<strong>非 null</strong>
类型的根（类似于 Java 中的 <code>Object</code>）。</p></li>
<li><p><strong>Any?:</strong> Корень вообще всех типов (включая
null).</p></li>
<li><p><strong>Any?:</strong> 所有类型的根（包括 null）。</p></li>
<li><p><strong>Unit:</strong> Аналог <code>void</code> (возвращается
функциями, которые ничего не возвращают).</p></li>
<li><p><strong>Unit:</strong> 类似于
<code>void</code>（由不返回任何内容的函数返回）。</p></li>
<li><p><strong>Nothing:</strong> Тип, у которого нет значений.
Используется для функций, которые никогда не завершаются (например,
выбрасывают исключение).</p></li>
<li><p><strong>Nothing:</strong>
没有值的类型。用于永远不会正常结束的函数（例如抛出异常）。</p></li>
</ul>
<hr />
<h3 id="поддержка-значения-null">2. Поддержка значения null</h3>
<p><strong>空值 (null) 支持</strong></p>
<p>Kotlin разделяет типы на те, которые могут быть null, и те, которые
не могут. Kotlin 将类型分为可以是 null 的类型和不可以是 null
的类型。</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Обычная строка. Null запрещен. Ошибка компиляции при присвоении null.</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 普通字符串。禁止 Null。赋值 null 会导致编译错误。</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> <span class="va">a</span><span class="op">:</span> <span class="kw">String</span> <span class="op">=</span> <span class="st">&quot;abc&quot;</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co">// a = null // Error!</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Строка, допускающая null (Nullable). Нужен вопросительный знак (?).</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 允许 null 的字符串 (Nullable)。需要问号 (?)。</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> <span class="va">b</span><span class="op">:</span> <span class="kw">String</span><span class="op">?</span> <span class="op">=</span> <span class="st">&quot;abc&quot;</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="kw">null</span> <span class="co">// OK</span></span></code></pre></div>
<hr />
<h3 id="оператор-безопасного-вызова-.-safe-call-operator">3. Оператор
безопасного вызова ?. (Safe Call Operator)</h3>
<p><strong>安全调用操作符 ?.</strong></p>
<p>Позволяет обратиться к свойству или методу, только если объект не
null. Если объект null, выражение возвращает null, а не падает с
ошибкой. 允许仅当对象不为 null 时访问属性或方法。如果对象为
null，表达式返回 null，而不是因错误崩溃。</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">b</span><span class="op">:</span> <span class="kw">String</span><span class="op">?</span> <span class="op">=</span> <span class="kw">null</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Если b не null, вернет длину. Если b == null, вернет null.</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 如果 b 不为 null，返回长度。如果 b == null，返回 null。</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">len</span><span class="op">:</span> <span class="kw">Int</span><span class="op">?</span> <span class="op">=</span> b<span class="op">?.</span>length </span></code></pre></div>
<hr />
<h3 id="оператор-элвис-elvis-operator">4. Оператор Элвис ?: (Elvis
Operator)</h3>
<p><strong>Elvis 操作符 ?:</strong></p>
<p>Используется для предоставления значения по умолчанию, если выражение
слева равно null. 用于在左侧表达式为 null 时提供默认值。</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">b</span><span class="op">:</span> <span class="kw">String</span><span class="op">?</span> <span class="op">=</span> <span class="kw">null</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Если длина есть — берем её. Если null — берем -1.</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 如果有长度则取长度。如果是 null，则取 -1。</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">len</span><span class="op">:</span> <span class="kw">Int</span> <span class="op">=</span> b<span class="op">?.</span>length <span class="op">?:</span> <span class="op">-</span><span class="dv">1</span></span></code></pre></div>
<hr />
<h3
id="проверка-на-null-с-помощью-оператора-not-null-assertion-operator">5.
Проверка на null с помощью оператора !! (Not-null Assertion
Operator)</h3>
<p><strong>使用 !! 操作符进行非空断言</strong></p>
<p>Превращает любой тип <code>T?</code> в <code>T</code>. Если значение
оказалось null, выбрасывается исключение
<code>NullPointerException</code>. 将任何类型 <code>T?</code> 转换为
<code>T</code>。如果值为 null，则抛出 <code>NullPointerException</code>
异常。</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">b</span><span class="op">:</span> <span class="kw">String</span><span class="op">?</span> <span class="op">=</span> <span class="kw">null</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: &quot;Я мамой клянусь, что b не null!&quot;. Если b == null -&gt; Crash.</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: “我发誓 b 不是 null！”。如果 b == null -&gt; 崩溃。</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">len</span><span class="op">:</span> <span class="kw">Int</span> <span class="op">=</span> b<span class="op">!!.</span>length </span></code></pre></div>
<hr />
<h3 id="безопасное-приведение-типов-оператор-as">6. Безопасное
приведение типов: оператор as?</h3>
<p><strong>安全类型转换：as? 操作符</strong></p>
<p>Пытается привести значение к указанному типу. Если не получается —
возвращает null (вместо исключения <code>ClassCastException</code>).
尝试将值转换为指定类型。如果失败，则返回 null（而不是
<code>ClassCastException</code> 异常）。</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">obj</span><span class="op">:</span> Any <span class="op">=</span> <span class="dv">123</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Пытаемся превратить число в строку. Не выйдет, вернется null.</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 尝试将数字转换为字符串。失败，返回 null。</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">str</span><span class="op">:</span> <span class="kw">String</span><span class="op">?</span> <span class="op">=</span> obj <span class="kw">as</span><span class="op">?</span> <span class="kw">String</span></span></code></pre></div>
<hr />
<h3 id="функция-let">7. Функция let</h3>
<p><strong>let 函数</strong></p>
<p>Часто используется вместе с <code>?.</code> для выполнения блока кода
только для не-null значений. 通常与 <code>?.</code> 一起使用，以便仅对非
null 值执行代码块。</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">email</span><span class="op">:</span> <span class="kw">String</span><span class="op">?</span> <span class="op">=</span> <span class="st">&quot;user@example.com&quot;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Блок выполнится, только если email != null.</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 仅当 email != null 时才执行代码块。</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>email<span class="op">?.</span>let <span class="op">{</span> </span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Внутри блока &#39;it&#39; — это не-null строка.</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 在代码块内部，&#39;it&#39; 是非 null 字符串。</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Sending to </span><span class="ss">$it</span><span class="st">&quot;</span><span class="op">)</span> </span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3
id="свойства-с-отложенной-инициализацией-late-initialized-properties">8.
Свойства с отложенной инициализацией (Late-initialized Properties)</h3>
<p><strong>延迟初始化属性</strong></p>
<p>Используется ключевое слово <code>lateinit var</code>. Это обещание
компилятору, что мы инициализируем переменную позже (до первого
использования). 使用 <code>lateinit var</code>
关键字。这是向编译器保证我们将稍后（在首次使用之前）初始化变量。</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MyService <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Работает только с var и ссылочными типами (не Int/Double).</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 仅适用于 var 和引用类型（不适用于 Int/Double）。</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lateinit</span> <span class="kw">var</span> <span class="va">data</span><span class="op">:</span> <span class="kw">String</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">init</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">data</span> <span class="op">=</span> <span class="st">&quot;Ready&quot;</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="расширение-типов-поддерживающих-значение-null">9. Расширение
типов поддерживающих значение null</h3>
<p><strong>支持空值的类型扩展</strong></p>
<p>Можно писать функции-расширения для nullable-типов (например,
<code>String?</code>). Внутри функции <code>this</code> может быть null.
可以为 nullable 类型（例如
<code>String?</code>）编写扩展函数。在函数内部，<code>this</code> 可能是
null。</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Стандартная функция Kotlin.</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: Kotlin 标准函数。</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">String</span>?<span class="op">.</span><span class="fu">isNullOrEmpty</span><span class="op">():</span> <span class="dt">Boolean</span> <span class="op">{</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Проверка на null происходит ВНУТРИ функции.</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: Null 检查发生在函数“内部”。</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="kw">this</span> <span class="op">==</span> <span class="kw">null</span> <span class="op">||</span> <span class="kw">this</span><span class="op">.</span>length <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">s</span><span class="op">:</span> <span class="kw">String</span><span class="op">?</span> <span class="op">=</span> <span class="kw">null</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Можно вызывать безопасно без ?.</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 可以安全调用，无需 ?.</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span>s<span class="op">.</span>isNullOrEmpty<span class="op">())</span> <span class="co">// true</span></span></code></pre></div>
<hr />
<h3 id="типы-и-подтипы-классы-и-подклассы">10. Типы и подтипы, классы и
подклассы</h3>
<p><strong>类型与子类型，类与子类</strong></p>
<p>В Kotlin <strong>Класс</strong> и <strong>Тип</strong> — это не одно
и то же. 在 Kotlin
中，<strong>类</strong>和<strong>类型</strong>不是一回事。</p>
<ul>
<li><p><strong>Class:</strong> <code>String</code> (это код, который мы
написали).</p></li>
<li><p><strong>Class:</strong>
<code>String</code>（这是我们编写的代码）。</p></li>
<li><p><strong>Types:</strong> Из одного класса <code>String</code>
получается два типа: <code>String</code> и
<code>String?</code>.</p></li>
<li><p><strong>Types:</strong> 一个 <code>String</code>
类产生两种类型：<code>String</code> 和 <code>String?</code>。</p></li>
<li><p><strong>Subtype:</strong> <code>String</code> является подтипом
<code>String?</code> (потому что мы можем присвоить <code>String</code>
туда, где ждут <code>String?</code>).</p></li>
<li><p><strong>Subtype:</strong> <code>String</code> 是
<code>String?</code> 的子类型（因为我们可以将 <code>String</code>
赋值给期望 <code>String?</code> 的地方）。</p></li>
</ul>
<hr />
<h3 id="изменяемые-и-неизменяемые-коллекции">11. Изменяемые и
неизменяемые коллекции</h3>
<p><strong>可变与不可变集合</strong></p>
<p>Kotlin строго разделяет интерфейсы коллекций. Kotlin
严格区分集合接口。</p>
<ul>
<li><p><strong>Immutable (Read-only):</strong> <code>List</code>,
<code>Set</code>, <code>Map</code>. У них нет методов <code>add</code>,
<code>remove</code>.</p></li>
<li><p><strong>Immutable (只读):</strong> <code>List</code>,
<code>Set</code>, <code>Map</code>. 它们没有 <code>add</code>,
<code>remove</code> 方法。</p></li>
<li><p><strong>Mutable:</strong> <code>MutableList</code>,
<code>MutableSet</code>, <code>MutableMap</code>. У них есть методы для
изменения.</p></li>
<li><p><strong>Mutable:</strong> <code>MutableList</code>,
<code>MutableSet</code>, <code>MutableMap</code>.
它们有修改方法。</p></li>
</ul>
<div class="sourceCode" id="cb54"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Read-only</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">readOnly</span><span class="op">:</span> List<span class="op">&lt;</span><span class="kw">Int</span><span class="op">&gt;</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Mutable</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">mutable</span><span class="op">:</span> MutableList<span class="op">&lt;</span><span class="kw">Int</span><span class="op">&gt;</span> <span class="op">=</span> mutableListOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>mutable<span class="op">.</span>add<span class="op">(</span><span class="dv">4</span><span class="op">)</span></span></code></pre></div>
<h1
id="обобщенные-типы-generic.-параметризованные-типы.-параметризованные-классы.-параметризованные-интерфейсы.-параметризованные-функции.-функции-с-параметризованным-получателем.-ограничение-типовых-параметров---класс.-ограничение-типовых-параметров---интерфейс.-несколько-ограничений-типовых-параметров.-обобщенные-типы-во-время-выполнения.-проверка-и-приведение-для-обобщенных-типов.-обобщенные-типы-во-встраиваемых-функциях-во-время-выполнения.-типы-и-подтипы.-вариантность-и-ковариантность-типов-variance.">9.
Обобщенные типы (Generic). Параметризованные типы. Параметризованные
классы. Параметризованные интерфейсы. Параметризованные функции. Функции
с параметризованным получателем. Ограничение типовых параметров - класс.
Ограничение типовых параметров - интерфейс. Несколько ограничений
типовых параметров. Обобщенные типы во время выполнения. Проверка и
приведение для обобщенных типов. Обобщенные типы во встраиваемых
функциях во время выполнения. Типы и подтипы. Вариантность и
ковариантность типов (variance).</h1>
<p>Это <strong>9-й вопрос (Question 9)</strong>, посвященный обобщениям
(Generics) в Kotlin. Это сложная, но важная тема для написания гибкого и
безопасного кода.</p>
<p>这是 <strong>第 9 题 (Question 9)</strong>，关于 Kotlin 中的泛型
(Generics)。这是一个复杂但对于编写灵活且安全的代码非常重要的主题。</p>
<hr />
<h3 id="обобщенные-типы-generic-и-параметризованные-типы">1. Обобщенные
типы (Generic) и Параметризованные типы</h3>
<p><strong>泛型与参数化类型</strong></p>
<p>Обобщения позволяют определять классы и методы, которые работают с
разными типами данных, не теряя строгой типизации.
泛型允许定义可以处理不同数据类型的类和方法，同时不丢失强类型检查。</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: &lt;T&gt; — это параметр типа. Мы можем подставить туда Int, String и т.д.</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: &lt;T&gt; 是类型参数。我们可以代入 Int, String 等。</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Box<span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;(</span><span class="va">t</span><span class="op">:</span> <span class="dt">T</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> <span class="va">value</span> <span class="op">=</span> t</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">box1</span><span class="op">:</span> Box<span class="op">&lt;</span><span class="kw">Int</span><span class="op">&gt;</span> <span class="op">=</span> Box<span class="op">(</span><span class="dv">1</span><span class="op">)</span>       <span class="co">// Параметризованный тип Box&lt;Int&gt; (参数化类型 Box&lt;Int&gt;)</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">box2</span><span class="op">:</span> Box<span class="op">&lt;</span><span class="kw">String</span><span class="op">&gt;</span> <span class="op">=</span> Box<span class="op">(</span><span class="st">&quot;Hi&quot;</span><span class="op">)</span> <span class="co">// Параметризованный тип Box&lt;String&gt; (参数化类型 Box&lt;String&gt;)</span></span></code></pre></div>
<hr />
<h3 id="параметризованные-классы">2. Параметризованные классы</h3>
<p><strong>参数化类</strong></p>
<p>Класс, который объявляет один или несколько типовых параметров в
угловых скобках <code>&lt;&gt;</code>. 在尖括号 <code>&lt;&gt;</code>
中声明一个或多个类型参数的类。</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Класс, который может хранить пару значений любых типов.</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 一个可以存储任意类型值对的类。</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Pair<span class="op">&lt;</span><span class="dt">A</span>, <span class="dt">B</span><span class="op">&gt;(</span><span class="kw">val</span> <span class="va">first</span><span class="op">:</span> <span class="dt">A</span><span class="op">,</span> <span class="kw">val</span> <span class="va">second</span><span class="op">:</span> <span class="dt">B</span><span class="op">)</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> pair = Pair<span class="op">(</span>1<span class="op">,</span> &quot;<span class="va">Apple</span>&quot;<span class="op">)</span> <span class="co">// A=Int, B=String</span></span></code></pre></div>
<hr />
<h3 id="параметризованные-интерфейсы">3. Параметризованные
интерфейсы</h3>
<p><strong>参数化接口</strong></p>
<p>Интерфейсы тоже могут быть обобщенными. Это часто используется в
коллекциях (List, Set). 接口也可以是泛型的。这常用于集合（List,
Set）。</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Repository<span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">save</span><span class="op">(</span><span class="va">item</span><span class="op">:</span> <span class="dt">T</span><span class="op">)</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">getById</span><span class="op">(</span><span class="va">id</span><span class="op">:</span> <span class="dt">Int</span><span class="op">):</span> <span class="dt">T</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Реализация интерфейса для конкретного типа User.</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 针对具体类型 User 的接口实现。</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="fu">UserRepository</span> <span class="op">:</span> <span class="dt">Repository</span><span class="op">&lt;</span><span class="dt">User</span><span class="op">&gt;</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="параметризованные-функции">4. Параметризованные функции</h3>
<p><strong>参数化函数</strong></p>
<p>Если класс не обобщенный, но функции нужна гибкость, мы можем сделать
обобщенной только функцию.
如果类不是泛型的，但函数需要灵活性，我们可以只让函数变成泛型。</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: &lt;T&gt; ставится перед именем функции.</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: &lt;T&gt; 放在函数名之前。</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span> <span class="fu">singletonList</span><span class="op">(</span><span class="va">item</span><span class="op">:</span> <span class="dt">T</span><span class="op">):</span> <span class="dt">List</span><span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> listOf<span class="op">(</span>item<span class="op">)</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="функции-с-параметризованным-получателем">5. Функции с
параметризованным получателем</h3>
<p><strong>带参数化接收者的函数</strong></p>
<p>Это функции-расширения для обобщенных типов.
这是针对泛型类型的扩展函数。</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Расширяем любой список List&lt;T&gt;. &#39;this&#39; имеет тип List&lt;T&gt;.</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 扩展任何列表 List&lt;T&gt;。&#39;this&#39; 的类型是 List&lt;T&gt;。</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span> <span class="fu">List</span><span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;.</span><span class="fu">secondOrNull</span><span class="op">():</span> <span class="dt">T</span><span class="op">?</span> <span class="op">{</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span><span class="op">.</span>size <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="kw">return</span> <span class="kw">null</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="kw">this</span><span class="op">[</span><span class="dv">1</span><span class="op">]</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="ограничение-типовых-параметров---класс">6. Ограничение типовых
параметров - класс</h3>
<p><strong>类型参数约束 - 类</strong></p>
<p>Мы можем ограничить тип <code>T</code>, указав, что он должен быть
наследником определенного класса. Используется двоеточие <code>:</code>.
我们可以通过指定 <code>T</code> 必须是特定类的子类来限制它。使用冒号
<code>:</code>。</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: T обязан быть числом (Number) или его наследником (Int, Double).</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: T 必须是 Number 或其子类（Int, Double）。</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="op">&lt;</span><span class="dt">T</span> <span class="op">:</span> <span class="dt">Number</span><span class="op">&gt;</span> <span class="fu">doubleValue</span><span class="op">(</span><span class="va">value</span><span class="op">:</span> <span class="dt">T</span><span class="op">):</span> <span class="dt">Double</span> <span class="op">{</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> value<span class="op">.</span>toDouble<span class="op">()</span> <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="ограничение-типовых-параметров---интерфейс">7. Ограничение
типовых параметров - интерфейс</h3>
<p><strong>类型参数约束 - 接口</strong></p>
<p>Синтаксис тот же. Часто используется для ограничения
<code>Comparable</code>. 语法相同。常用于限制
<code>Comparable</code>。</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Элементы должны быть сравниваемыми (Comparable).</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 元素必须是可比较的 (Comparable)。</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="op">&lt;</span><span class="dt">T</span> <span class="op">:</span> <span class="dt">Comparable</span><span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;&gt;</span> <span class="fu">sort</span><span class="op">(</span><span class="va">list</span><span class="op">:</span> <span class="dt">List</span>&lt;<span class="va">T</span>&gt;<span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="несколько-ограничений-типовых-параметров">8. Несколько
ограничений типовых параметров</h3>
<p><strong>多个类型参数约束</strong></p>
<p>Если нужно несколько ограничений, используется ключевое слово
<code>where</code> в конце. 如果需要多个约束，在末尾使用关键字
<code>where</code>。</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: T должен быть CharSequence И Comparable.</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: T 必须同时是 CharSequence 和 Comparable。</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span> <span class="fu">copyGreaterThan</span><span class="op">(</span><span class="va">list</span><span class="op">:</span> <span class="dt">List</span>&lt;<span class="va">T</span>&gt;<span class="op">,</span> <span class="va">threshold</span><span class="op">:</span> <span class="dt">T</span><span class="op">):</span> <span class="dt">List</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> <span class="fu">T</span> <span class="op">:</span> <span class="dt">CharSequence</span>,</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>          <span class="fu">T</span> <span class="op">:</span> <span class="dt">Comparable</span><span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*...*/</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> emptyList<span class="op">()</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="обобщенные-типы-во-время-выполнения">9. Обобщенные типы во время
выполнения</h3>
<p><strong>运行时的泛型类型</strong></p>
<p>В Kotlin (как и в Java) generics существуют только на этапе
компиляции. В runtime происходит <strong>стирание типов</strong> (Type
Erasure). 在 Kotlin 中（就像在 Java
中一样），泛型仅存在于编译阶段。在运行时会发生<strong>类型擦除</strong>
(Type Erasure)。</p>
<ul>
<li><code>List&lt;String&gt;</code> и <code>List&lt;Int&gt;</code> в
runtime превращаются просто в <code>List</code>.</li>
<li><code>List&lt;String&gt;</code> 和 <code>List&lt;Int&gt;</code>
在运行时都会变成 <code>List</code>。</li>
</ul>
<hr />
<h3 id="проверка-и-приведение-для-обобщенных-типов">10. Проверка и
приведение для обобщенных типов</h3>
<p><strong>泛型类型的检查与转换</strong></p>
<p>Из-за стирания типов мы не можем проверить
<code>is List&lt;String&gt;</code>. Мы можем проверить только
<code>is List&lt;*&gt;</code>. 由于类型擦除，我们无法检查
<code>is List&lt;String&gt;</code>。我们只能检查
<code>is List&lt;*&gt;</code>。</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">check</span><span class="op">(</span><span class="va">a</span><span class="op">:</span> <span class="dt">Any</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// if (a is List&lt;String&gt;) // Error! Cannot check for instance of erased type</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Star-projection (Звездная проекция). Мы проверяем, что это список чего-то.</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 星号投影 (Star-projection)。我们检查它是否是某种列表。</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="kw">is</span> List<span class="op">&lt;*&gt;)</span> <span class="op">{</span> </span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;It&#39;s a list&quot;</span><span class="op">)</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Unchecked cast (предупреждение компилятора).</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 未经检查的转换 (编译器警告)。</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> a <span class="kw">as</span> List<span class="op">&lt;</span><span class="kw">String</span><span class="op">&gt;</span> </span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3
id="обобщенные-типы-во-встраиваемых-функциях-во-время-выполнения-reified">11.
Обобщенные типы во встраиваемых функциях во время выполнения
(Reified)</h3>
<p><strong>内联函数运行时的具体化泛型</strong></p>
<p>Это уникальная фича Kotlin. Если функция <code>inline</code>, мы
можем использовать <code>reified</code>, чтобы сохранить тип в runtime.
这是 Kotlin 的独特功能。如果函数是 <code>inline</code> 的，我们可以使用
<code>reified</code> 来在运行时保留类型。</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Ключевое слово reified спасает от стирания типов.</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 关键字 reified 防止了类型擦除。</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="kw">fun</span> <span class="op">&lt;</span><span class="kw">reified</span> <span class="dt">T</span><span class="op">&gt;</span> <span class="fu">isA</span><span class="op">(</span><span class="va">value</span><span class="op">:</span> <span class="dt">Any</span><span class="op">):</span> <span class="dt">Boolean</span> <span class="op">{</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Теперь мы МОЖЕМ проверить тип T!</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 现在我们“可以”检查类型 T 了！</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> value <span class="kw">is</span> T</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">isString</span> <span class="op">=</span> isA<span class="op">&lt;</span><span class="kw">String</span><span class="op">&gt;(</span><span class="st">&quot;Hello&quot;</span><span class="op">)</span> <span class="co">// true</span></span></code></pre></div>
<hr />
<h3 id="типы-и-подтипы">12. Типы и подтипы</h3>
<p><strong>类型与子类型</strong></p>
<p>Важно понимать: <code>String</code> — подтип <code>Any</code>. Но
<code>MutableList&lt;String&gt;</code> — <strong>НЕ</strong> подтип
<code>MutableList&lt;Any&gt;</code>.
理解这一点很重要：<code>String</code> 是 <code>Any</code> 的子类型。但
<code>MutableList&lt;String&gt;</code> <strong>不是</strong>
<code>MutableList&lt;Any&gt;</code> 的子类型。</p>
<ul>
<li>Если бы это было так, мы могли бы положить <code>Int</code> в список
строк, что вызвало бы ошибку.</li>
<li>如果是这样的话，我们就可以把 <code>Int</code>
放进字符串列表，这会导致错误。</li>
</ul>
<hr />
<h3 id="вариантность-и-ковариантность-типов-variance">13. Вариантность и
ковариантность типов (variance)</h3>
<p><strong>类型的变型与协变</strong></p>
<p>Чтобы обойти ограничение из пункта 12, используются ключевые слова
<code>out</code> (Covariance) и <code>in</code> (Contravariance).
为了绕过第 12 点的限制，使用关键字 <code>out</code>（协变）和
<code>in</code>（逆变）。</p>
<ul>
<li><p><strong>Producer (out T):</strong> Мы только
<strong>читаем</strong> T. (Covariant / 协变).</p></li>
<li><p><code>List&lt;String&gt;</code> является подтипом
<code>List&lt;Any&gt;</code> (потому что <code>List</code> в Kotlin —
это read-only интерфейс с <code>out T</code>).</p></li>
<li><p><code>List&lt;String&gt;</code> 是 <code>List&lt;Any&gt;</code>
的子类型（因为 Kotlin 中的 <code>List</code> 是带有 <code>out T</code>
的只读接口）。</p></li>
<li><p><strong>Consumer (in T):</strong> Мы только
<strong>пишем</strong> T. (Contravariant / 逆变).</p></li>
<li><p><code>Comparable&lt;Number&gt;</code> является подтипом
<code>Comparable&lt;Int&gt;</code>.</p></li>
<li><p><code>Comparable&lt;Number&gt;</code> 是
<code>Comparable&lt;Int&gt;</code> 的子类型。</p></li>
</ul>
<div class="sourceCode" id="cb65"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: out = только возвращаем (производим).</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: out = 只返回 (生产)。</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Producer<span class="op">&lt;</span><span class="kw">out</span> <span class="dt">T</span><span class="op">&gt;(</span><span class="kw">val</span> <span class="va">value</span><span class="op">:</span> <span class="dt">T</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="kw">get</span><span class="op">():</span> <span class="dt">T</span> <span class="op">=</span> value</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">p</span><span class="op">:</span> Producer<span class="op">&lt;</span>Any<span class="op">&gt;</span> <span class="op">=</span> Producer<span class="op">&lt;</span><span class="kw">String</span><span class="op">&gt;(</span><span class="st">&quot;test&quot;</span><span class="op">)</span> <span class="co">// OK</span></span></code></pre></div>
<h1
id="анонимная-функция-в-kotlin.-функциональный-тип.-псевдоним-функционального-типа.-лямбда-выражение.-лямбда-выражение-для-вызова-функции.-лямбда-выражение-как-последний-параметр-функции.-лямбда-выражение-как-ссылка-на-функцию.-лямбда-в-функциях-filter-map-foreach.-интерфейсы-iterable-и-iterator.-функции-с-предикатами-all-any-count-и-find.-группирование-элементов-коллекции.">10.
Анонимная функция в Kotlin. Функциональный тип. Псевдоним
функционального типа. Лямбда-выражение. Лямбда-выражение для вызова
функции. Лямбда-выражение как последний параметр функции.
Лямбда-выражение как ссылка на функцию. Лямбда в функциях filter, map,
forEach. Интерфейсы Iterable и Iterator. Функции с предикатами all, any,
count и find. Группирование элементов коллекции.</h1>
<p>Это <strong>10-й вопрос (Question 10)</strong>, посвященный
функциональному программированию в Kotlin. Это одна из самых сильных
сторон языка.</p>
<p>这是 <strong>第 10 题 (Question 10)</strong>，关于 Kotlin
中的函数式编程。这是该语言最强大的优势之一。</p>
<p>Мы разберем каждую тему по порядку. 我们将按顺序解析每个主题。</p>
<hr />
<h3 id="анонимная-функция-в-kotlin">1. Анонимная функция в Kotlin</h3>
<p><strong>Kotlin 中的匿名函数</strong></p>
<p>Это функция без имени. В отличие от лямбд, здесь можно явно указать
тип возвращаемого значения. 这是一个没有名字的函数。与 Lambda
不同，这里可以显式指定返回值类型。</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Анонимная функция. Мы явно пишем &#39;fun&#39; и тип возврата &#39;: Int&#39;.</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 匿名函数。我们要显式写出 &#39;fun&#39; 和返回类型 &#39;: Int&#39;。</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">multiply</span> <span class="op">=</span> <span class="kw">fun</span><span class="op">(</span><span class="va">x</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="va">y</span><span class="op">:</span> <span class="dt">Int</span><span class="op">):</span> <span class="dt">Int</span> <span class="op">{</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> x <span class="op">*</span> y</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="функциональный-тип">2. Функциональный тип</h3>
<p><strong>函数类型</strong></p>
<p>Переменная может хранить функцию. Тип такой переменной описывается
как <code>(Параметры) -&gt; Результат</code>.
变量可以存储函数。这种变量的类型描述为
<code>(参数) -&gt; 结果</code>。</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Переменная &#39;sum&#39; имеет функциональный тип: принимает два Int, возвращает Int.</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 变量 &#39;sum&#39; 具有函数类型：接收两个 Int，返回 Int。</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">sum</span><span class="op">:</span> <span class="op">(</span><span class="kw">Int</span><span class="op">,</span> <span class="kw">Int</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">Int</span> <span class="op">=</span> <span class="op">{</span> a<span class="op">,</span> b <span class="op">-&gt;</span> a <span class="op">+</span> b <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="псевдоним-функционального-типа-type-alias">3. Псевдоним
функционального типа (Type Alias)</h3>
<p><strong>函数类型别名</strong></p>
<p>Если функциональный тип слишком длинный, ему можно дать короткое имя
с помощью <code>typealias</code>. 如果函数类型太长，可以使用
<code>typealias</code> 给它起一个简短的名字。</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Даем имя сложному типу обработчика клика.</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 给复杂的点击处理程序类型起个名字。</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typealias</span> ClickHandler <span class="op">=</span> <span class="op">(</span>Button<span class="op">,</span> Event<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">Unit</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">setOnClick</span><span class="op">(</span><span class="va">handler</span><span class="op">:</span> <span class="dt">ClickHandler</span><span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="лямбда-выражение">4. Лямбда-выражение</h3>
<p><strong>Lambda 表达式</strong></p>
<p>Это краткий способ записи анонимной функции. Всегда пишется в
фигурных скобках <code>{}</code>.
这是编写匿名函数的简洁方式。总是写在花括号 <code>{}</code> 中。</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Лямбда. Параметры слева от -&gt;, тело справа.</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: Lambda。参数在 -&gt; 左边，函数体在右边。</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">greet</span> <span class="op">=</span> <span class="op">{</span> name<span class="op">:</span> <span class="kw">String</span> <span class="op">-&gt;</span> println<span class="op">(</span><span class="st">&quot;Hello, </span><span class="ss">$name</span><span class="st">&quot;</span><span class="op">)</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="лямбда-выражение-для-вызова-функции">5. Лямбда-выражение для
вызова функции</h3>
<p><strong>用于调用函数的 Lambda 表达式</strong></p>
<p>Лямбду можно вызвать методом <code>invoke()</code> или просто как
обычную функцию <code>()</code>. 可以通过 <code>invoke()</code>
方法或直接像普通函数 <code>()</code> 一样调用 Lambda。</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">square</span> <span class="op">=</span> <span class="op">{</span> x<span class="op">:</span> <span class="kw">Int</span> <span class="op">-&gt;</span> x <span class="op">*</span> x <span class="op">}</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Способ 1 (Method 1)</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span>square<span class="op">(</span><span class="dv">5</span><span class="op">))</span> </span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Способ 2 (Method 2)</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span>square<span class="op">.</span>invoke<span class="op">(</span><span class="dv">5</span><span class="op">))</span></span></code></pre></div>
<hr />
<h3
id="лямбда-выражение-как-последний-параметр-функции-trailing-lambda">6.
Лямбда-выражение как последний параметр функции (Trailing Lambda)</h3>
<p><strong>作为函数最后一个参数的 Lambda 表达式（尾随
Lambda）</strong></p>
<p>Если лямбда — это <strong>последний</strong> аргумент функции, её
можно вынести <strong>за скобки</strong>. Это “фирменный стиль” Kotlin.
如果 Lambda
是函数的<strong>最后一个</strong>参数，可以将其移至<strong>括号外</strong>。这是
Kotlin 的“标志性风格”。</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">runAsync</span><span class="op">(</span><span class="va">delay</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="va">action</span><span class="op">:</span> <span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">Unit</span><span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Лямбда вынесена за круглые скобки. Выглядит как встроенная конструкция языка.</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: Lambda 被移到了圆括号外面。看起来像是语言的内置结构。</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>runAsync<span class="op">(</span><span class="dv">1000</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Done!&quot;</span><span class="op">)</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="лямбда-выражение-как-ссылка-на-функцию">7. Лямбда-выражение как
ссылка на функцию</h3>
<p><strong>作为函数引用的 Lambda 表达式</strong></p>
<p>Вместо того чтобы писать <code>{ x -&gt; func(x) }</code>, можно
использовать ссылку на уже существующую функцию через <code>::</code>.
与其写 <code>{ x -&gt; func(x) }</code>，不如通过 <code>::</code>
使用对现有函数的引用。</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">isEven</span><span class="op">(</span><span class="va">x</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">=</span> x <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Передаем ссылку на функцию isEven.</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 传递对函数 isEven 的引用。</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>list<span class="op">.</span>filter<span class="op">(::</span>isEven<span class="op">)</span> </span></code></pre></div>
<hr />
<h3 id="лямбда-в-функциях-filter-map-foreach">8. Лямбда в функциях
filter, map, forEach</h3>
<p><strong>filter, map, forEach 函数中的 Lambda</strong></p>
<p>Это стандартные функции высшего порядка для работы с коллекциями.
这些是用于处理集合的标准高阶函数。</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">)</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 1. filter: Оставляет только то, что true.</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 1. filter: 只保留 true 的项。</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: &#39;it&#39; — это неявное имя единственного параметра лямбды.</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: &#39;it&#39; 是 Lambda 唯一参数的隐式名称。</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">evens</span> <span class="op">=</span> list<span class="op">.</span>filter <span class="op">{</span> it <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">}</span> </span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a><span class="co">// 2. map: Преобразует каждый элемент.</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a><span class="co">// 2. map: 转换每个元素。</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">squared</span> <span class="op">=</span> list<span class="op">.</span>map <span class="op">{</span> it <span class="op">*</span> it <span class="op">}</span></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a><span class="co">// 3. forEach: Действие для каждого элемента.</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a><span class="co">// 3. forEach: 对每个元素执行操作。</span></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>list<span class="op">.</span>forEach <span class="op">{</span> println<span class="op">(</span>it<span class="op">)</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="интерфейсы-iterable-и-iterator">9. Интерфейсы Iterable и
Iterator</h3>
<p><strong>Iterable 和 Iterator 接口</strong></p>
<p><code>Iterable</code> — это коллекция, по которой можно пройтись.
<code>Iterator</code> — это объект-курсор, который делает шаги.
<code>Iterable</code> 是可以遍历的集合。<code>Iterator</code>
是执行步进操作的光标对象。</p>
<ul>
<li><strong>Iterable:</strong> Имеет метод <code>iterator()</code>.
(拥有 <code>iterator()</code> 方法).</li>
<li><strong>Iterator:</strong> Имеет методы <code>hasNext()</code> и
<code>next()</code>. (拥有 <code>hasNext()</code> 和 <code>next()</code>
方法).</li>
</ul>
<hr />
<h3 id="функции-с-предикатами-all-any-count-и-find">10. Функции с
предикатами all, any, count и find</h3>
<p><strong>带有谓词 all, any, count 和 find 的函数</strong></p>
<p>Предикат — это лямбда, возвращающая <code>Boolean</code>. 谓词是返回
<code>Boolean</code> 的 Lambda。</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">numbers</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">)</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Все элементы больше 0? -&gt; true</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 所有元素都大于 0 吗？-&gt; true</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">allPositive</span> <span class="op">=</span> numbers<span class="op">.</span>all <span class="op">{</span> it <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">}</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Есть ли хоть один элемент больше 10? -&gt; false</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 有没有至少一个元素大于 10？-&gt; false</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">hasBigNumber</span> <span class="op">=</span> numbers<span class="op">.</span>any <span class="op">{</span> it <span class="op">&gt;</span> <span class="dv">10</span> <span class="op">}</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Сколько четных чисел? -&gt; 2</span></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 有多少个偶数？-&gt; 2</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">evenCount</span> <span class="op">=</span> numbers<span class="op">.</span>count <span class="op">{</span> it <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">}</span></span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Найти первый элемент больше 3. -&gt; 4</span></span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 找到第一个大于 3 的元素。-&gt; 4</span></span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">firstBig</span> <span class="op">=</span> numbers<span class="op">.</span>find <span class="op">{</span> it <span class="op">&gt;</span> <span class="dv">3</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="группирование-элементов-коллекции">11. Группирование элементов
коллекции</h3>
<p><strong>集合元素分组</strong></p>
<p>Функция <code>groupBy</code> превращает список в карту
(<code>Map</code>), где ключ — это критерий группировки.
<code>groupBy</code> 函数将列表转换为映射
(<code>Map</code>)，其中键是分组标准。</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">words</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;abc&quot;</span><span class="op">,</span> <span class="st">&quot;ab&quot;</span><span class="op">,</span> <span class="st">&quot;def&quot;</span><span class="op">,</span> <span class="st">&quot;abcd&quot;</span><span class="op">)</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Группируем слова по их длине.</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 按长度对单词进行分组。</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">byLength</span><span class="op">:</span> Map<span class="op">&lt;</span><span class="kw">Int</span><span class="op">,</span> List<span class="op">&lt;</span><span class="kw">String</span><span class="op">&gt;&gt;</span> <span class="op">=</span> words<span class="op">.</span>groupBy <span class="op">{</span> it<span class="op">.</span>length <span class="op">}</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Result:</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a><span class="co">// 1 -&gt; [&quot;a&quot;]</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a><span class="co">// 2 -&gt; [&quot;ab&quot;]</span></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a><span class="co">// 3 -&gt; [&quot;abc&quot;, &quot;def&quot;]</span></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a><span class="co">// 4 -&gt; [&quot;abcd&quot;]</span></span></code></pre></div>
<h1
id="функция-анонимная-функция-лямбда.-функция-расширение-анонимная-функция-расширение-лямбда-с-получателем.-функциональный-тип-с-получателем.-лямбда-выражение-с-получателем.-стандартная-функция-with.-стандартная-функция-apply.-стандартная-функция-let.-стандартная-функция-run.-объявление-функциональных-интерфейсов-в-kotlin-1.4.">11.
Функция, анонимная функция, лямбда. Функция-расширение, анонимная
функция-расширение, лямбда с получателем. Функциональный тип с
получателем. Лямбда-выражение с получателем. Стандартная функция with.
Стандартная функция apply. Стандартная функция let. Стандартная функция
run. Объявление функциональных интерфейсов в Kotlin 1.4.</h1>
<p>Это <strong>11-й вопрос (Question 11)</strong>, который углубляется в
тему функций и контекста (Receiver) в Kotlin. Это база для понимания DSL
(Domain Specific Languages) и стандартной библиотеки.</p>
<p>这是 <strong>第 11 题 (Question 11)</strong>，深入探讨 Kotlin
中的函数和上下文 (Receiver)。这是理解
DSL（领域特定语言）和标准库的基础。</p>
<p>Мы разберем каждое понятие по порядку. 我们将按顺序解析每个概念。</p>
<hr />
<h3 id="функция-анонимная-функция-лямбда">1. Функция, анонимная функция,
лямбда</h3>
<p><strong>函数，匿名函数，Lambda</strong></p>
<p>Это три способа определить блок кода. 这是定义代码块的三种方式。</p>
<ul>
<li><p><strong>Функция (Function):</strong> Именованная, объявлена через
<code>fun</code>.</p></li>
<li><p><strong>函数 (Function):</strong> 具名的，通过 <code>fun</code>
声明。</p></li>
<li><p><strong>Анонимная функция (Anonymous Function):</strong>
<code>fun(...)</code> без имени. Позволяет явно указать
<code>return</code>.</p></li>
<li><p><strong>匿名函数 (Anonymous Function):</strong> 没有名字的
<code>fun(...)</code>。允许显式指定 <code>return</code>。</p></li>
<li><p><strong>Лямбда (Lambda):</strong> Выражение в <code>{}</code>.
Самый краткий синтаксис.</p></li>
<li><p><strong>Lambda:</strong> <code>{}</code>
中的表达式。语法最简洁。</p></li>
</ul>
<div class="sourceCode" id="cb76"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 1. Обычная функция (Regular function)</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">add</span><span class="op">(</span><span class="va">x</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="va">y</span><span class="op">:</span> <span class="dt">Int</span><span class="op">):</span> <span class="dt">Int</span> <span class="op">=</span> x <span class="op">+</span> y</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 2. Анонимная функция (Anonymous function)</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Используется, когда нужен явный return или сложная логика возврата.</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 当需要显式 return 或复杂的返回逻辑时使用。</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">anon</span> <span class="op">=</span> <span class="kw">fun</span><span class="op">(</span><span class="va">x</span><span class="op">:</span> <span class="dt">Int</span><span class="op">,</span> <span class="va">y</span><span class="op">:</span> <span class="dt">Int</span><span class="op">):</span> <span class="dt">Int</span> <span class="op">{</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> x <span class="op">+</span> y</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a><span class="co">// 3. Лямбда (Lambda)</span></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Самый частый вариант.</span></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 最常见的选项。</span></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">lambda</span> <span class="op">=</span> <span class="op">{</span> x<span class="op">:</span> <span class="kw">Int</span><span class="op">,</span> y<span class="op">:</span> <span class="kw">Int</span> <span class="op">-&gt;</span> x <span class="op">+</span> y <span class="op">}</span></span></code></pre></div>
<hr />
<h3
id="функция-расширение-анонимная-функция-расширение-лямбда-с-получателем">2.
Функция-расширение, анонимная функция-расширение, лямбда с
получателем</h3>
<p><strong>扩展函数，匿名扩展函数，带接收者的 Lambda</strong></p>
<p>Эти механизмы позволяют вызывать функцию так, будто она является
частью класса. 这些机制允许像调用类的一部分一样调用函数。</p>
<ul>
<li><p><strong>Функция-расширение:</strong>
<code>fun String.lastChar()</code></p></li>
<li><p><strong>扩展函数:</strong>
<code>fun String.lastChar()</code></p></li>
<li><p><strong>Анонимная функция-расширение:</strong>
<code>fun String.() { ... }</code></p></li>
<li><p><strong>匿名扩展函数:</strong>
<code>fun String.() { ... }</code></p></li>
<li><p><strong>Лямбда с получателем:</strong> Блок кода, где
<code>this</code> указывает на расширяемый объект.</p></li>
<li><p><strong>带接收者的 Lambda:</strong> 代码块，其中
<code>this</code> 指向被扩展的对象。</p></li>
</ul>
<hr />
<h3 id="функциональный-тип-с-получателем">3. Функциональный тип с
получателем</h3>
<p><strong>带接收者的函数类型</strong></p>
<p>Это <strong>тип</strong> переменной, который описывает, что функция
должна вызываться на определенном объекте.
这是变量的<strong>类型</strong>，描述了函数必须在特定对象上调用。</p>
<p><strong>Синтаксис (Syntax):</strong>
<code>Receiver.(Params) -&gt; ReturnType</code></p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Тип переменной: функция, которая вызывается на Int и ничего не возвращает.</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 变量类型：在 Int 上调用且不返回任何内容的函数。</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">sum</span><span class="op">:</span> <span class="kw">Int</span><span class="op">.(</span><span class="kw">Int</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">Int</span></span></code></pre></div>
<hr />
<h3 id="лямбда-выражение-с-получателем">4. Лямбда-выражение с
получателем</h3>
<p><strong>带接收者的 Lambda 表达式</strong></p>
<p>Это сама <strong>реализация</strong> функционального типа с
получателем. Внутри лямбды объект доступен через <code>this</code>.
这是带接收者的函数类型的<strong>实现</strong>本身。在 Lambda
内部，可以通过 <code>this</code> 访问对象。</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Реализация типа из пункта 3.</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 第 3 点中类型的实现。</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">sum</span><span class="op">:</span> <span class="kw">Int</span><span class="op">.(</span><span class="kw">Int</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">Int</span> <span class="op">=</span> <span class="op">{</span> other <span class="op">-&gt;</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: &#39;this&#39; — это первое число (получатель). &#39;other&#39; — аргумент.</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: &#39;this&#39; 是第一个数字（接收者）。&#39;other&#39; 是参数。</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span> <span class="op">+</span> other</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">result</span> <span class="op">=</span> <span class="fl">1.</span>sum<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="co">// 3</span></span></code></pre></div>
<hr />
<h3 id="стандартная-функция-with">5. Стандартная функция with</h3>
<p><strong>标准函数 with</strong></p>
<p>Принимает объект и лямбду с получателем. Используется для группировки
вызовов методов одного объекта. <strong>Не является
расширением.</strong> 接收一个对象和一个带接收者的
Lambda。用于对同一个对象的方法调用进行分组。<strong>不是扩展函数。</strong></p>
<ul>
<li><strong>Context:</strong> <code>this</code></li>
<li><strong>Return:</strong> Результат лямбды (Result of lambda).</li>
</ul>
<div class="sourceCode" id="cb79"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">sb</span> <span class="op">=</span> StringBuilder<span class="op">()</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: &quot;С этим объектом (sb) сделай следующее...&quot;</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: “对这个对象 (sb) 做以下事情……”</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">result</span> <span class="op">=</span> with<span class="op">(</span>sb<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>    append<span class="op">(</span><span class="st">&quot;Hello&quot;</span><span class="op">)</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>    append<span class="op">(</span><span class="st">&quot; World&quot;</span><span class="op">)</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span>toString<span class="op">()</span> <span class="co">// Return value</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="стандартная-функция-apply">6. Стандартная функция apply</h3>
<p><strong>标准函数 apply</strong></p>
<p>Используется для <strong>настройки (инициализации) объекта</strong>.
Возвращает <strong>сам объект</strong>.
用于<strong>配置（初始化）对象</strong>。返回<strong>对象本身</strong>。</p>
<ul>
<li><strong>Context:</strong> <code>this</code></li>
<li><strong>Return:</strong> Объект (The object itself).</li>
</ul>
<div class="sourceCode" id="cb80"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Создаем объект и сразу настраиваем его поля.</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 创建对象并立即配置其字段。</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">person</span> <span class="op">=</span> Person<span class="op">().</span>apply <span class="op">{</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    name <span class="op">=</span> <span class="st">&quot;John&quot;</span>  <span class="co">// this.name = &quot;John&quot;</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>    age <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// person variable = initialized object</span></span></code></pre></div>
<hr />
<h3 id="стандартная-функция-let">7. Стандартная функция let</h3>
<p><strong>标准函数 let</strong></p>
<p>Используется для выполнения действий с результатом выражения (часто
для проверки на null). 用于对表达式的结果执行操作（常用于 null
检查）。</p>
<ul>
<li><strong>Context:</strong> <code>it</code> (аргумент / argument)</li>
<li><strong>Return:</strong> Результат лямбды (Result of lambda).</li>
</ul>
<div class="sourceCode" id="cb81"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">str</span><span class="op">:</span> <span class="kw">String</span><span class="op">?</span> <span class="op">=</span> <span class="st">&quot;Hello&quot;</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Выполнится, только если str не null.</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 仅当 str 不为 null 时执行。</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>str<span class="op">?.</span>let <span class="op">{</span> </span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Здесь доступ через &#39;it&#39;.</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 这里通过 &#39;it&#39; 访问。</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span>it<span class="op">.</span>length<span class="op">)</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="стандартная-функция-run">8. Стандартная функция run</h3>
<p><strong>标准函数 run</strong></p>
<p>Это комбинация <code>with</code> и <code>let</code>. 这是
<code>with</code> 和 <code>let</code> 的结合体。</p>
<ol type="1">
<li><strong>Как расширение (object.run):</strong> Похож на
<code>let</code>, но внутри <code>this</code>. (Контекст
<code>this</code>, возвращает результат лямбды).</li>
<li><strong>Без расширения (run { … }):</strong> Просто запускает блок
кода.</li>
</ol>
<div class="sourceCode" id="cb82"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">service</span> <span class="op">=</span> Service<span class="op">()</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Настраиваем и вычисляем результат (в отличие от apply, который вернул бы service).</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 配置并计算结果（与 apply 不同，apply 会返回 service）。</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">initResult</span> <span class="op">=</span> service<span class="op">.</span>run <span class="op">{</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>    port <span class="op">=</span> <span class="dv">8080</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>    start<span class="op">()</span> <span class="co">// returns Boolean</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="объявление-функциональных-интерфейсов-в-kotlin-1.4">9.
Объявление функциональных интерфейсов в Kotlin 1.4</h3>
<p><strong>Kotlin 1.4 中函数式接口的声明</strong></p>
<p>Раньше SAM-конверсия (Single Abstract Method) работала только для
Java-интерфейсов. Начиная с версии 1.4, можно объявлять SAM-интерфейсы в
Kotlin, используя ключевое слово <code>fun interface</code>. 以前，SAM
转换（单抽象方法）仅适用于 Java 接口。从 1.4 版本开始，可以使用关键字
<code>fun interface</code> 在 Kotlin 中声明 SAM 接口。</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Ключевое слово fun перед interface.</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: interface 前面的 fun 关键字。</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="kw">interface</span> <span class="fu">Predicate</span> <span class="op">{</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">accept</span><span class="op">(</span><span class="va">i</span><span class="op">:</span> <span class="dt">Int</span><span class="op">):</span> <span class="dt">Boolean</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Теперь можно использовать лямбду вместо создания объекта.</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 现在可以使用 Lambda 代替创建对象。</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="fu">isEven</span> <span class="op">=</span> Predicate <span class="op">{</span> it <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">}</span></span></code></pre></div>
<h1
id="виды-коллекций.-изменяемые-и-не-изменяемые.-итераторы-и-итерируемые.-изменяемая-коллекция.-виды-коллекций.-list-список.-изменяемый-список.-виды-коллекций.-set-множество.-виды-коллекций.-map-карта.-конструирование-множеств.-конструирование-списков.-конструирование-карт.-итераторы-над-коллекциями.">12.
Виды коллекций. Изменяемые и не изменяемые. Итераторы и итерируемые.
Изменяемая коллекция. Виды коллекций. List (Список). Изменяемый список.
Виды коллекций. Set (Множество). Виды коллекций. Map (Карта).
Конструирование множеств. Конструирование списков. Конструирование карт.
Итераторы над коллекциями.</h1>
<p>Это <strong>12-й вопрос (Question 12)</strong>, посвященный
коллекциям в Kotlin. 这是 <strong>第 12 题 (Question 12)</strong>，关于
Kotlin 中的集合。</p>
<p>Мы разберем каждое понятие по порядку. 我们将按顺序解析每个概念。</p>
<hr />
<h3 id="виды-коллекций">1. Виды коллекций</h3>
<p><strong>集合的类型</strong></p>
<p>В стандартной библиотеке Kotlin основные типы коллекций — это
<strong>List</strong> (Список), <strong>Set</strong> (Множество) и
<strong>Map</strong> (Карта/Словарь). 在 Kotlin
标准库中，主要的集合类型是
<strong>List</strong>（列表）、<strong>Set</strong>（集）和
<strong>Map</strong>（映射/字典）。</p>
<hr />
<h3 id="изменяемые-и-не-изменяемые">2. Изменяемые и не изменяемые</h3>
<p><strong>可变与不可变</strong></p>
<p>Kotlin строго разделяет коллекции на два типа интерфейсов:</p>
<ol type="1">
<li><strong>Read-only (Immutable):</strong> Только для чтения (нет
методов <code>add</code>, <code>remove</code>).</li>
<li><strong>Mutable:</strong> Изменяемые (наследуются от Read-only и
добавляют методы изменения).</li>
</ol>
<p>Kotlin 严格将集合分为两种类型的接口：</p>
<ol type="1">
<li><strong>Read-only (不可变):</strong> 只读（没有 <code>add</code>,
<code>remove</code> 方法）。</li>
<li><strong>Mutable (可变):</strong> 可变（继承自 Read-only
并添加了修改方法）。</li>
</ol>
<hr />
<h3 id="итераторы-и-итерируемые">3. Итераторы и итерируемые</h3>
<p><strong>迭代器与可迭代对象</strong></p>
<ul>
<li><strong>Iterable:</strong> Интерфейс, который имеет метод
<code>iterator()</code>. По нему можно запустить цикл
<code>for</code>.</li>
<li><strong>Iterator:</strong> Объект, который выполняет обход, имея
методы <code>hasNext()</code> и <code>next()</code>.</li>
<li><strong>Iterable:</strong> 拥有 <code>iterator()</code>
方法的接口。可以在其上运行 <code>for</code> 循环。</li>
<li><strong>Iterator:</strong> 执行遍历的对象，拥有
<code>hasNext()</code> 和 <code>next()</code> 方法。</li>
</ul>
<hr />
<h3 id="изменяемая-коллекция-mutablecollection">4. Изменяемая коллекция
(MutableCollection)</h3>
<p><strong>可变集合</strong></p>
<p>Это общий интерфейс для коллекций, которые можно менять. Он добавляет
методы <code>add</code>, <code>remove</code>, <code>clear</code>.
这是可修改集合的通用接口。它添加了 <code>add</code>,
<code>remove</code>, <code>clear</code> 方法。</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">modify</span><span class="op">(</span><span class="va">collection</span><span class="op">:</span> <span class="dt">MutableCollection</span>&lt;<span class="va">String</span>&gt;<span class="op">)</span> <span class="op">{</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Мы можем добавлять, так как это Mutable.</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 我们可以添加，因为这是 Mutable。</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    collection<span class="op">.</span>add<span class="op">(</span><span class="st">&quot;New Item&quot;</span><span class="op">)</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="list-список">5. List (Список)</h3>
<p><strong>列表</strong></p>
<p>Упорядоченная коллекция. Элементы имеют индексы (0, 1, 2…). Дубликаты
разрешены. Интерфейс <code>List</code> — только для чтения.
有序集合。元素具有索引 (0, 1, 2…)。允许重复。<code>List</code>
接口仅供读取。</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Нельзя добавить элементы сюда.</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 不能往这里添加元素。</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span><span class="op">:</span> List<span class="op">&lt;</span><span class="kw">Int</span><span class="op">&gt;</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">item</span> <span class="op">=</span> list<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="co">// Access by index</span></span></code></pre></div>
<hr />
<h3 id="изменяемый-список-mutablelist">6. Изменяемый список
(MutableList)</h3>
<p><strong>可变列表</strong></p>
<p>Наследник <code>List</code>, который позволяет изменять элементы по
индексу, добавлять и удалять их. <code>List</code>
的子接口，允许通过索引修改元素，以及添加和删除元素。</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">numbers</span><span class="op">:</span> MutableList<span class="op">&lt;</span><span class="kw">Int</span><span class="op">&gt;</span> <span class="op">=</span> mutableListOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Замена элемента по индексу.</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 通过索引替换元素。</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>numbers<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">10</span> </span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>numbers<span class="op">.</span>add<span class="op">(</span><span class="dv">4</span><span class="op">)</span></span></code></pre></div>
<hr />
<h3 id="set-множество">7. Set (Множество)</h3>
<p><strong>集 (Set)</strong></p>
<p>Коллекция уникальных элементов. Порядок элементов не гарантирован (в
общем случае). 唯一元素的集合。通常不保证元素的顺序。</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Единица добавится только один раз.</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 数字 1 只会被添加一次。</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">set</span> <span class="op">=</span> setOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span> <span class="co">// {1, 2, 3}</span></span></code></pre></div>
<hr />
<h3 id="map-карта">8. Map (Карта)</h3>
<p><strong>映射 (Map)</strong></p>
<p>Набор пар “Ключ-Значение” (Key-Value). Ключи уникальны, значения
могут повторяться. <strong>Важно:</strong> <code>Map</code> не
наследуется от интерфейса <code>Collection</code>. “键-值”对 (Key-Value)
的集合。键是唯一的，值可以重复。 <strong>重要提示：</strong>
<code>Map</code> 不继承自 <code>Collection</code> 接口。</p>
<hr />
<h3 id="конструирование-множеств">9. Конструирование множеств</h3>
<p><strong>构建 Set</strong></p>
<p>Используются функции <code>setOf()</code> (для неизменяемых) и
<code>mutableSetOf()</code> (для изменяемых). 使用
<code>setOf()</code>（用于不可变）和
<code>mutableSetOf()</code>（用于可变）函数。</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">readOnlySet</span> <span class="op">=</span> setOf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="st">&quot;B&quot;</span><span class="op">)</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">mutableSet</span> <span class="op">=</span> mutableSetOf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="st">&quot;B&quot;</span><span class="op">)</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>mutableSet<span class="op">.</span>add<span class="op">(</span><span class="st">&quot;C&quot;</span><span class="op">)</span></span></code></pre></div>
<hr />
<h3 id="конструирование-списков">10. Конструирование списков</h3>
<p><strong>构建 List</strong></p>
<p>Используются функции <code>listOf()</code> и
<code>mutableListOf()</code>. Самая частая операция. 使用
<code>listOf()</code> 和 <code>mutableListOf()</code>
函数。这是最常见的操作。</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">empty</span> <span class="op">=</span> emptyList<span class="op">&lt;</span><span class="kw">String</span><span class="op">&gt;()</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">values</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: ArrayList под капотом.</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 底层是 ArrayList。</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">arrayList</span> <span class="op">=</span> arrayListOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span> </span></code></pre></div>
<hr />
<h3 id="конструирование-карт">11. Конструирование карт</h3>
<p><strong>构建 Map</strong></p>
<p>Используются функции <code>mapOf()</code> и
<code>mutableMapOf()</code>. Для создания пар используется инфиксная
функция <code>to</code>. 使用 <code>mapOf()</code> 和
<code>mutableMapOf()</code> 函数。使用中缀函数 <code>to</code>
创建键值对。</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: &quot;Key&quot; to &quot;Value&quot;.</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: &quot;Key&quot; to &quot;Value&quot;.</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">map</span> <span class="op">=</span> mapOf<span class="op">(</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span> to <span class="st">&quot;One&quot;</span><span class="op">,</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span> to <span class="st">&quot;Two&quot;</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
<hr />
<h3 id="итераторы-над-коллекциями">12. Итераторы над коллекциями</h3>
<p><strong>集合上的迭代器</strong></p>
<p>Вы можете получить итератор вручную, но чаще используется цикл
<code>for</code>. 您可以手动获取迭代器，但更常用的是 <code>for</code>
循环。</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="st">&quot;B&quot;</span><span class="op">)</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Способ 1: Явный итератор (Explicit Iterator)</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">iterator</span> <span class="op">=</span> list<span class="op">.</span>iterator<span class="op">()</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>iterator<span class="op">.</span>hasNext<span class="op">())</span> <span class="op">{</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span>iterator<span class="op">.</span>next<span class="op">())</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Способ 2: Цикл for (скрывает итератор)</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a><span class="co">// 方法 2: for 循环 (隐藏了迭代器)</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>item <span class="kw">in</span> list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span>item<span class="op">)</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1
id="преобразования-коллекций.-mapping.-преобразования-карт.-mapping.-преобразования-коллекций.-zipping.-преобразования-коллекций.-association.-преобразования-коллекций.-flattening.-фильтрация-коллекций.-predicate.-фильтрация-коллекций.-partitioning.-фильтрация-коллекций.-testing-predicates.-операторы-и---для-работы-с-коллекциями.-группирование.-groupby.-восстановление-частей-коллекции.-slice.-восстановление-частей-коллекции.-take-drop.">13.
Преобразования коллекций. Mapping. Преобразования карт. Mapping.
Преобразования коллекций. Zipping. Преобразования коллекций.
Association. Преобразования коллекций. Flattening. Фильтрация коллекций.
predicate. Фильтрация коллекций. Partitioning. Фильтрация коллекций.
Testing predicates. Операторы + и - для работы с коллекциями.
Группирование. groupBy. Восстановление частей коллекции. Slice.
Восстановление частей коллекции. take &amp; drop.</h1>
<p>Это <strong>13-й вопрос (Question 13)</strong>, посвященный мощным
инструментам преобразования коллекций в Kotlin. Это основа
функционального стиля работы с данными.</p>
<p>这是 <strong>第 13 题 (Question 13)</strong>，关于 Kotlin
中强大的集合转换工具。这是处理数据的函数式风格的基础。</p>
<p>Мы разберем каждый пункт по порядку. 我们将按顺序解析每一点。</p>
<hr />
<h3 id="преобразования-коллекций.-mapping.">1. Преобразования коллекций.
Mapping.</h3>
<p><strong>集合转换：Mapping (映射)</strong></p>
<p>Функция <code>map</code> создает новую коллекцию, применяя
функцию-трансформер к каждому элементу. <code>map</code>
函数通过对每个元素应用转换函数来创建一个新集合。</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">numbers</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Возводим каждое число в квадрат.</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 将每个数字平方。</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">squared</span> <span class="op">=</span> numbers<span class="op">.</span>map <span class="op">{</span> it <span class="op">*</span> it <span class="op">}</span> <span class="co">// [1, 4, 9]</span></span></code></pre></div>
<hr />
<h3 id="преобразования-карт.-mapping.">2. Преобразования карт.
Mapping.</h3>
<p><strong>Map (映射) 的转换</strong></p>
<p>Для <code>Map</code> есть специальные функции: <code>mapKeys</code>
(изменяет ключи) и <code>mapValues</code> (изменяет значения). 对于
<code>Map</code>，有特殊的函数：<code>mapKeys</code>（更改键）和
<code>mapValues</code>（更改值）。</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">numbersMap</span> <span class="op">=</span> mapOf<span class="op">(</span><span class="st">&quot;key1&quot;</span> to <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;key2&quot;</span> to <span class="dv">2</span><span class="op">)</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Изменяем только значения (умножаем на 10).</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 只更改值（乘以 10）。</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">newMap</span> <span class="op">=</span> numbersMap<span class="op">.</span>mapValues <span class="op">{</span> entry <span class="op">-&gt;</span> entry<span class="op">.</span>value <span class="op">*</span> <span class="dv">10</span> <span class="op">}</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Result: {key1=10, key2=20}</span></span></code></pre></div>
<hr />
<h3 id="преобразования-коллекций.-zipping.">3. Преобразования коллекций.
Zipping.</h3>
<p><strong>集合转换：Zipping (配对)</strong></p>
<p>Функция <code>zip</code> объединяет две коллекции в одну, создавая
список пар (<code>Pair</code>). Длина результата равна длине самой
короткой коллекции. <code>zip</code> 函数将两个集合合并为一个，创建对
(<code>Pair</code>) 的列表。结果的长度等于最短集合的长度。</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">names</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;Alice&quot;</span><span class="op">,</span> <span class="st">&quot;Bob&quot;</span><span class="op">)</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">ages</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="dv">40</span><span class="op">)</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: &quot;Alice&quot; c 20, &quot;Bob&quot; c 30. 40 игнорируется.</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: &quot;Alice&quot; 配 20，&quot;Bob&quot; 配 30。40 被忽略。</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">pairs</span> <span class="op">=</span> names<span class="op">.</span>zip<span class="op">(</span>ages<span class="op">)</span> </span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Result: [(&quot;Alice&quot;, 20), (&quot;Bob&quot;, 30)]</span></span></code></pre></div>
<hr />
<h3 id="преобразования-коллекций.-association.">4. Преобразования
коллекций. Association.</h3>
<p><strong>集合转换：Association (关联)</strong></p>
<p>Позволяет создать <code>Map</code> из списка.</p>
<ul>
<li><code>associateWith</code>: Элементы списка становятся ключами.</li>
<li><code>associateBy</code>: Элементы списка становятся
значениями.</li>
</ul>
<p>允许从列表创建 <code>Map</code>。</p>
<ul>
<li><code>associateWith</code>: 列表元素成为键。</li>
<li><code>associateBy</code>: 列表元素成为值。</li>
</ul>
<div class="sourceCode" id="cb95"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">keys</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">)</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Ключи - буквы, значения - их длина.</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 键是字母，值是它们的长度。</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">map</span> <span class="op">=</span> keys<span class="op">.</span>associateWith <span class="op">{</span> it<span class="op">.</span>length <span class="op">}</span> </span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a><span class="co">// { &quot;a&quot;=1, &quot;b&quot;=1 }</span></span></code></pre></div>
<hr />
<h3 id="преобразования-коллекций.-flattening.">5. Преобразования
коллекций. Flattening.</h3>
<p><strong>集合转换：Flattening (扁平化)</strong></p>
<p>Превращает вложенные коллекции (список списков) в один плоский
список.</p>
<ul>
<li><code>flatten()</code>: Просто объединяет.</li>
<li><code>flatMap()</code>: Сначала преобразует (map), потом объединяет
(flatten).</li>
</ul>
<p>将嵌套集合（列表的列表）转换为一个扁平列表。</p>
<ul>
<li><code>flatten()</code>: 只是合并。</li>
<li><code>flatMap()</code>: 先转换 (map)，后合并 (flatten)。</li>
</ul>
<div class="sourceCode" id="cb96"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">nested</span> <span class="op">=</span> listOf<span class="op">(</span>listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">),</span> listOf<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">))</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Результат: [1, 2, 3, 4]</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 结果：[1, 2, 3, 4]</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">flat</span> <span class="op">=</span> nested<span class="op">.</span>flatten<span class="op">()</span></span></code></pre></div>
<hr />
<h3 id="фильтрация-коллекций.-predicate.">6. Фильтрация коллекций.
predicate.</h3>
<p><strong>集合过滤：predicate (谓词)</strong></p>
<p>Предикат — это условие (лямбда), возвращающее <code>true</code> или
<code>false</code>. Функция <code>filter</code> оставляет только те
элементы, для которых предикат вернул <code>true</code>. 谓词是返回
<code>true</code> 或 <code>false</code> 的条件
(Lambda)。<code>filter</code> 函数只保留谓词返回 <code>true</code>
的元素。</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">)</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Оставляем только четные.</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 只保留偶数。</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">evens</span> <span class="op">=</span> list<span class="op">.</span>filter <span class="op">{</span> it <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">}</span> <span class="co">// [2, 4]</span></span></code></pre></div>
<hr />
<h3 id="фильтрация-коллекций.-partitioning.">7. Фильтрация коллекций.
Partitioning.</h3>
<p><strong>集合过滤：Partitioning (分区)</strong></p>
<p>Разделяет коллекцию на <strong>две</strong>: одна с элементами,
подходящими под условие, вторая — с остальными.
将集合分为<strong>两个</strong>：一个包含符合条件的元素，另一个包含其余元素。</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Результат — это Пара (Pair) из двух списков.</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 结果是由两个列表组成的对 (Pair)。</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> (<span class="va">match</span><span class="op">,</span> rest<span class="op">)</span> <span class="op">=</span> list<span class="op">.</span>partition <span class="op">{</span> it <span class="op">&gt;</span> <span class="dv">2</span> <span class="op">}</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a><span class="co">// match: [3, 4]</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a><span class="co">// rest: [1, 2]</span></span></code></pre></div>
<hr />
<h3 id="фильтрация-коллекций.-testing-predicates.">8. Фильтрация
коллекций. Testing predicates.</h3>
<p><strong>集合过滤：Testing predicates (测试谓词)</strong></p>
<p>Проверка элементов на соответствие условию (возвращает Boolean).</p>
<ul>
<li><code>any()</code>: Хотя бы один.</li>
<li><code>all()</code>: Все.</li>
<li><code>none()</code>: Ни один.</li>
</ul>
<p>检查元素是否符合条件（返回 Boolean）。</p>
<ul>
<li><code>any()</code>: 至少一个。</li>
<li><code>all()</code>: 所有。</li>
<li><code>none()</code>: 没有一个。</li>
</ul>
<div class="sourceCode" id="cb99"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">hasEven</span> <span class="op">=</span> list<span class="op">.</span>any <span class="op">{</span> it <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">}</span> <span class="co">// true</span></span></code></pre></div>
<hr />
<h3 id="операторы-и---для-работы-с-коллекциями">9. Операторы + и - для
работы с коллекциями</h3>
<p><strong>用于集合的 + 和 - 操作符</strong></p>
<p>Эти операторы создают <strong>новую</strong> коллекцию, добавляя или
удаляя элементы (не меняя исходную).
这些操作符创建<strong>新</strong>集合，添加或删除元素（不更改原始集合）。</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">)</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Создается новый список.</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 创建一个新列表。</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">plusList</span> <span class="op">=</span> list <span class="op">+</span> <span class="st">&quot;B&quot;</span> <span class="co">// [&quot;A&quot;, &quot;B&quot;]</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">minusList</span> <span class="op">=</span> plusList <span class="op">-</span> <span class="st">&quot;A&quot;</span> <span class="co">// [&quot;B&quot;]</span></span></code></pre></div>
<hr />
<h3 id="группирование.-groupby.">10. Группирование. groupBy.</h3>
<p><strong>分组：groupBy</strong></p>
<p>Группирует элементы в <code>Map</code>, где ключ — это критерий
группировки, а значение — список элементов. 将元素分组到
<code>Map</code> 中，其中键是分组标准，值是元素列表。</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">words</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;one&quot;</span><span class="op">,</span> <span class="st">&quot;two&quot;</span><span class="op">,</span> <span class="st">&quot;three&quot;</span><span class="op">)</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Группируем по первой букве.</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 按首字母分组。</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">byFirstChar</span> <span class="op">=</span> words<span class="op">.</span>groupBy <span class="op">{</span> it<span class="op">.</span>first<span class="op">()</span> <span class="op">}</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Result: { &#39;o&#39;=[one], &#39;t&#39;=[two, three] }</span></span></code></pre></div>
<hr />
<h3 id="восстановление-частей-коллекции.-slice.">11. Восстановление
частей коллекции. Slice.</h3>
<p><strong>获取集合部分：Slice (切片)</strong></p>
<p>Возвращает список элементов по указанным индексам (диапазону или
набору). 返回指定索引（范围或集合）处的元素列表。</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">,</span> <span class="st">&quot;c&quot;</span><span class="op">,</span> <span class="st">&quot;d&quot;</span><span class="op">)</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Элементы с индексами от 1 до 3.</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 索引从 1 到 3 的元素。</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">sub</span> <span class="op">=</span> list<span class="op">.</span>slice<span class="op">(</span><span class="fl">1..3</span><span class="op">)</span> <span class="co">// [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span></code></pre></div>
<hr />
<h3 id="восстановление-частей-коллекции.-take-drop.">12. Восстановление
частей коллекции. take &amp; drop.</h3>
<p><strong>获取集合部分：take &amp; drop (取与丢)</strong></p>
<ul>
<li><code>take(n)</code>: Взять первые <code>n</code> элементов.</li>
<li><code>drop(n)</code>: Пропустить первые <code>n</code> элементов и
вернуть остальные.</li>
<li><code>takeLast(n)</code> / <code>dropLast(n)</code>: То же самое, но
с конца.</li>
<li><code>take(n)</code>: 取前 <code>n</code> 个元素。</li>
<li><code>drop(n)</code>: 跳过前 <code>n</code>
个元素并返回其余元素。</li>
<li><code>takeLast(n)</code> / <code>dropLast(n)</code>:
同样的操作，但是从末尾开始。</li>
</ul>
<div class="sourceCode" id="cb103"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">)</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">firstTwo</span> <span class="op">=</span> list<span class="op">.</span>take<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="co">// [1, 2]</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">withoutFirst</span> <span class="op">=</span> list<span class="op">.</span>drop<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="co">// [2, 3, 4]</span></span></code></pre></div>
<h1
id="получение-элемента.-по-позиции.-получение-случайного-элемента.-проверка-существования-элемента.-упорядочение-коллекции.-собственный-порядок-коллекции.-обратный-порядок-коллекции.-случайный-порядок-коллекции.-агрегатные-операции.-min-sum-average.-агрегатные-операции.-maxby-maxwith.-функции-fold-и-reduce.-функции-foldindexed-и-foldrightindexed.-изменения-в-коллекции.-добавление.-изменения-в-коллекции.-удаление.">14.
Получение элемента. По позиции. Получение случайного элемента. Проверка
существования элемента. Упорядочение коллекции. Собственный порядок
коллекции. Обратный порядок коллекции. Случайный порядок коллекции.
Агрегатные операции. min, sum, average. Агрегатные операции. maxBy,
maxWith. Функции fold и reduce. Функции foldIndexed и foldRightIndexed.
Изменения в коллекции. Добавление. Изменения в коллекции. Удаление.</h1>
<p>Это <strong>14-й вопрос (Question 14)</strong>, посвященный операциям
получения данных, сортировки, агрегации и модификации коллекций в
Kotlin.</p>
<p>这是 <strong>第 14 题 (Question 14)</strong>，关于 Kotlin
中集合的数据获取、排序、聚合和修改操作。</p>
<p>Мы разберем каждый пункт по порядку. 我们将按顺序解析每一点。</p>
<hr />
<h3 id="получение-элемента.-по-позиции.">1. Получение элемента. По
позиции.</h3>
<p><strong>获取元素：按位置</strong></p>
<p>Для списков (<code>List</code>) элементы можно получать по индексу.
对于列表 (<code>List</code>)，可以通过索引获取元素。</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="st">&quot;B&quot;</span><span class="op">,</span> <span class="st">&quot;C&quot;</span><span class="op">)</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 1. Оператор [] (The [] operator)</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">item1</span> <span class="op">=</span> list<span class="op">[</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a><span class="co">// 2. Безопасное получение (Safe retrieval)</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Если индекса нет, вернет null (не упадет).</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 如果索引不存在，返回 null（不会崩溃）。</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">item2</span> <span class="op">=</span> list<span class="op">.</span>getOrNull<span class="op">(</span><span class="dv">10</span><span class="op">)</span> </span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a><span class="co">// 3. Значение по умолчанию (Default value)</span></span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Если индекса нет, вернет &quot;Unknown&quot;.</span></span>
<span id="cb104-13"><a href="#cb104-13" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 如果索引不存在，返回 &quot;Unknown&quot;。</span></span>
<span id="cb104-14"><a href="#cb104-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">item3</span> <span class="op">=</span> list<span class="op">.</span>getOrElse<span class="op">(</span><span class="dv">10</span><span class="op">)</span> <span class="op">{</span> <span class="st">&quot;Unknown&quot;</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="получение-случайного-элемента.">2. Получение случайного
элемента.</h3>
<p><strong>获取随机元素</strong></p>
<p>Используются функции <code>random()</code> или
<code>randomOrNull()</code>. 使用 <code>random()</code> 或
<code>randomOrNull()</code> 函数。</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Вернет случайное число из списка.</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 返回列表中的一个随机数。</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">randomItem</span> <span class="op">=</span> list<span class="op">.</span>random<span class="op">()</span></span></code></pre></div>
<hr />
<h3 id="проверка-существования-элемента.">3. Проверка существования
элемента.</h3>
<p><strong>检查元素是否存在</strong></p>
<p>Используется оператор <code>in</code> или метод
<code>contains()</code>. Также <code>isEmpty()</code> для проверки
пустоты. 使用 <code>in</code> 操作符或 <code>contains()</code>
方法。还有用于检查是否为空的 <code>isEmpty()</code>。</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="st">&quot;B&quot;</span><span class="op">)</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Оператор in (более идиоматично).</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: in 操作符（更符合惯用法）。</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">exists</span> <span class="op">=</span> <span class="st">&quot;A&quot;</span> <span class="kw">in</span> list <span class="co">// true</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Метод contains.</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: contains 方法。</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">exists2</span> <span class="op">=</span> list<span class="op">.</span>contains<span class="op">(</span><span class="st">&quot;Z&quot;</span><span class="op">)</span> <span class="co">// false</span></span></code></pre></div>
<hr />
<h3 id="упорядочение-коллекции.">4. Упорядочение коллекции.</h3>
<p><strong>集合排序</strong></p>
<p>Стандартная сортировка (по возрастанию) для типов, реализующих
<code>Comparable</code> (числа, строки). 针对实现了
<code>Comparable</code> 的类型（数字、字符串）的标准排序（升序）。</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">numbers</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Возвращает НОВЫЙ отсортированный список.</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 返回一个排好序的“新”列表。</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">sorted</span> <span class="op">=</span> numbers<span class="op">.</span>sorted<span class="op">()</span> <span class="co">// [1, 2, 3]</span></span></code></pre></div>
<hr />
<h3 id="собственный-порядок-коллекции.">5. Собственный порядок
коллекции.</h3>
<p><strong>自定义集合顺序</strong></p>
<p>Используется функция <code>sortedBy</code> (сортировка по какому-то
свойству) или <code>sortedWith</code> (Comparator). 使用
<code>sortedBy</code> 函数（按属性排序）或 <code>sortedWith</code>
(Comparator)。</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">words</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;Banana&quot;</span><span class="op">,</span> <span class="st">&quot;Apple&quot;</span><span class="op">,</span> <span class="st">&quot;Pear&quot;</span><span class="op">)</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Сортировка по длине слова.</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 按单词长度排序。</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">byLength</span> <span class="op">=</span> words<span class="op">.</span>sortedBy <span class="op">{</span> it<span class="op">.</span>length <span class="op">}</span> </span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="co">// [Pear, Apple, Banana] (4, 5, 6 letters)</span></span></code></pre></div>
<hr />
<h3 id="обратный-порядок-коллекции.">6. Обратный порядок коллекции.</h3>
<p><strong>集合反序</strong></p>
<p>Можно просто перевернуть список (<code>reversed</code>) или
отсортировать по убыванию (<code>sortedDescending</code>).
可以直接反转列表 (<code>reversed</code>) 或按降序排序
(<code>sortedDescending</code>)。</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Просто переворачивает список задом наперед.</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 只是将列表倒过来。</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">reversed</span> <span class="op">=</span> list<span class="op">.</span>reversed<span class="op">()</span> <span class="co">// [3, 2, 1]</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Сортирует от большего к меньшему.</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 从大到小排序。</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">descending</span> <span class="op">=</span> list<span class="op">.</span>sortedDescending<span class="op">()</span></span></code></pre></div>
<hr />
<h3 id="случайный-порядок-коллекции.">7. Случайный порядок
коллекции.</h3>
<p><strong>集合随机顺序</strong></p>
<p>Используется функция <code>shuffled()</code>. Это “перетасовка”
колоды. 使用 <code>shuffled()</code> 函数。这是像“洗牌”一样的操作。</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Каждый раз разный порядок.</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 每次顺序都不同。</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">mixed</span> <span class="op">=</span> list<span class="op">.</span>shuffled<span class="op">()</span> </span></code></pre></div>
<hr />
<h3 id="агрегатные-операции.-min-sum-average.">8. Агрегатные операции.
min, sum, average.</h3>
<p><strong>聚合操作：min, sum, average</strong></p>
<p>Операции, которые сводят коллекцию к одному значению.</p>
<ul>
<li><code>minOrNull()</code>: Минимальный элемент (в старых версиях был
<code>min</code>).</li>
<li><code>sum()</code>: Сумма (только для чисел).</li>
<li><code>average()</code>: Среднее значение (Double).</li>
</ul>
<p>将集合规约为单个值的操作。</p>
<ul>
<li><code>minOrNull()</code>: 最小元素（旧版本中是
<code>min</code>）。</li>
<li><code>sum()</code>: 求和（仅限数字）。</li>
<li><code>average()</code>: 平均值 (Double)。</li>
</ul>
<hr />
<h3 id="агрегатные-операции.-maxby-maxwith.">9. Агрегатные операции.
maxBy, maxWith.</h3>
<p><strong>聚合操作：maxBy, maxWith</strong></p>
<p>Поиск максимального элемента <strong>по критерию</strong>.
<strong>按标准</strong>查找最大元素。</p>
<ul>
<li><code>maxByOrNull { selector }</code>: Максимум по возвращаемому
значению селектора.</li>
<li><code>maxWithOrNull (Comparator)</code>: Максимум с использованием
компаратора.</li>
<li><code>maxByOrNull { selector }</code>:
根据选择器返回值求最大值。</li>
<li><code>maxWithOrNull (Comparator)</code>: 使用比较器求最大值。</li>
</ul>
<div class="sourceCode" id="cb111"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;abc&quot;</span><span class="op">,</span> <span class="st">&quot;ab&quot;</span><span class="op">)</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Самая длинная строка.</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 最长的字符串。</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">longest</span> <span class="op">=</span> list<span class="op">.</span>maxByOrNull <span class="op">{</span> it<span class="op">.</span>length <span class="op">}</span> <span class="co">// &quot;abc&quot;</span></span></code></pre></div>
<hr />
<h3 id="функции-fold-и-reduce.">10. Функции fold и reduce.</h3>
<p><strong>fold 和 reduce 函数</strong></p>
<p>Эти функции последовательно применяют операцию к элементам и
накапливают результат. 这些函数依次对元素应用操作并累积结果。</p>
<ul>
<li><strong>reduce:</strong> Первый элемент становится начальным
значением аккумулятора. (Пустой список вызовет ошибку).</li>
<li><strong>fold:</strong> Принимает <strong>начальное значение</strong>
аккумулятора явно. (Безопасен для пустого списка).</li>
<li><strong>reduce:</strong>
第一个元素成为累加器的初始值。（空列表会导致错误）。</li>
<li><strong>fold:</strong>
显式接收累加器的<strong>初始值</strong>。（对空列表安全）。</li>
</ul>
<div class="sourceCode" id="cb112"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">numbers</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Начинаем с 0. 0+1 -&gt; 1+2 -&gt; 3+3 = 6.</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 从 0 开始。0+1 -&gt; 1+2 -&gt; 3+3 = 6。</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">sumFold</span> <span class="op">=</span> numbers<span class="op">.</span>fold<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">{</span> acc<span class="op">,</span> item <span class="op">-&gt;</span> acc <span class="op">+</span> item <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="функции-foldindexed-и-foldrightindexed.">11. Функции foldIndexed
и foldRightIndexed.</h3>
<p><strong>foldIndexed 和 foldRightIndexed 函数</strong></p>
<ul>
<li><code>foldIndexed</code>: То же, что <code>fold</code>, но лямбда
получает индекс элемента.</li>
<li><code>foldRightIndexed</code>: Итерация идет с конца списка к началу
(справа налево).</li>
<li><code>foldIndexed</code>: 与 <code>fold</code> 相同，但 Lambda
会接收元素的索引。</li>
<li><code>foldRightIndexed</code>: 从列表末尾向前迭代（从右到左）。</li>
</ul>
<div class="sourceCode" id="cb113"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="st">&quot;B&quot;</span><span class="op">)</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: acc - аккумулятор, i - индекс, s - строка.</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: acc - 累加器, i - 索引, s - 字符串。</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">res</span> <span class="op">=</span> list<span class="op">.</span>foldIndexed<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">)</span> <span class="op">{</span> i<span class="op">,</span> acc<span class="op">,</span> s <span class="op">-&gt;</span> </span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;</span><span class="ss">$acc</span><span class="st"> </span><span class="ss">$i</span><span class="st">:</span><span class="ss">$s</span><span class="st">&quot;</span> </span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> </span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Result: &quot; 0:A 1:B&quot;</span></span></code></pre></div>
<hr />
<h3 id="изменения-в-коллекции.-добавление.">12. Изменения в коллекции.
Добавление.</h3>
<p><strong>集合修改：添加</strong></p>
<p>Работает только с <code>MutableList</code>. 仅适用于
<code>MutableList</code>。</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">mutableList</span> <span class="op">=</span> mutableListOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Добавить один элемент.</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 添加一个元素。</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>mutableList<span class="op">.</span>add<span class="op">(</span><span class="dv">3</span><span class="op">)</span> </span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Добавить другую коллекцию (addAll).</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 添加另一个集合 (addAll)。</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>mutableList <span class="op">+=</span> listOf<span class="op">(</span><span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">)</span> <span class="co">// [1, 2, 3, 4, 5]</span></span></code></pre></div>
<hr />
<h3 id="изменения-в-коллекции.-удаление.">13. Изменения в коллекции.
Удаление.</h3>
<p><strong>集合修改：删除</strong></p>
<p>Работает только с <code>MutableList</code>. 仅适用于
<code>MutableList</code>。</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> mutableListOf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="st">&quot;B&quot;</span><span class="op">,</span> <span class="st">&quot;C&quot;</span><span class="op">)</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Удалить конкретный объект (вернет true, если удалил).</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 删除特定对象（如果删除了则返回 true）。</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>list<span class="op">.</span>remove<span class="op">(</span><span class="st">&quot;B&quot;</span><span class="op">)</span> </span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Удалить по индексу.</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 按索引删除。</span></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>list<span class="op">.</span>removeAt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="co">// Удалит &quot;A&quot;</span></span></code></pre></div>
<h1
id="списки.-доступ-по-индексу.-линейный-поиск.-двоичный-поиск-в-сортированных-списках.-двоичный-поиск-с-компаратором.-двоичный-поиск-с-функцией-сравнения.-добавление-и-обновление.-удаление.-сортировка.">15.
Списки. Доступ по индексу. Линейный поиск. Двоичный поиск в
сортированных списках. Двоичный поиск с компаратором. Двоичный поиск с
функцией сравнения. Добавление и обновление. Удаление. Сортировка.</h1>
<p>Это <strong>15-й вопрос (Question 15)</strong>. Я повторю его разбор,
но на этот раз <strong>без картинок</strong>, чтобы вам было удобно
копировать текст.</p>
<p>这是 <strong>第 15 题 (Question
15)</strong>。我会重新解析一遍，但这次<strong>不包含图片</strong>，以便您复制文本。</p>
<hr />
<h3 id="списки">1. Списки</h3>
<p><strong>列表</strong></p>
<p>В Kotlin списки (<code>List</code>) — это упорядоченные коллекции
элементов. Каждый элемент имеет свою позицию (индекс). 在 Kotlin
中，列表 (<code>List</code>)
是元素的有序集合。每个元素都有自己的位置（索引）。</p>
<hr />
<h3 id="доступ-по-индексу">2. Доступ по индексу</h3>
<p><strong>按索引访问</strong></p>
<p>Индексация начинается с нуля. Для доступа используются квадратные
скобки <code>[]</code> или метод <code>get()</code>.
索引从零开始。使用方括号 <code>[]</code> 或 <code>get()</code>
方法进行访问。</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="st">&quot;B&quot;</span><span class="op">,</span> <span class="st">&quot;C&quot;</span><span class="op">)</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Получаем элемент с индексом 1.</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 获取索引为 1 的元素。</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">item</span> <span class="op">=</span> list<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="co">// &quot;B&quot;</span></span></code></pre></div>
<hr />
<h3 id="линейный-поиск">3. Линейный поиск</h3>
<p><strong>线性搜索</strong></p>
<p>Это стандартный поиск, который проверяет элементы один за другим.
Работает на любых списках, но медленно (O(n)).
这是标准的搜索方式，逐个检查元素。适用于任何列表，但速度较慢
(O(n))。</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">numbers</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="dv">20</span><span class="op">)</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Найти индекс первого вхождения числа 20.</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 查找数字 20 第一次出现的索引。</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">index</span> <span class="op">=</span> numbers<span class="op">.</span>indexOf<span class="op">(</span><span class="dv">20</span><span class="op">)</span> <span class="co">// 1</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Найти индекс последнего вхождения.</span></span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 查找最后一次出现的索引。</span></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">lastIndex</span> <span class="op">=</span> numbers<span class="op">.</span>lastIndexOf<span class="op">(</span><span class="dv">20</span><span class="op">)</span> <span class="co">// 3</span></span></code></pre></div>
<hr />
<h3 id="двоичный-поиск-в-сортированных-списках">4. Двоичный поиск в
сортированных списках</h3>
<p><strong>排序列表中的二分查找</strong></p>
<p>Работает <strong>только</strong> в отсортированных списках. Делит
список пополам, поэтому работает очень быстро (O(log n)).
<strong>仅</strong>适用于已排序的列表。它将列表一分为二，因此速度非常快
(O(log n))。</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">sortedList</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">)</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Ищем число 7.</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 搜索数字 7。</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">index</span> <span class="op">=</span> sortedList<span class="op">.</span>binarySearch<span class="op">(</span><span class="dv">7</span><span class="op">)</span> <span class="co">// 3</span></span></code></pre></div>
<hr />
<h3 id="двоичный-поиск-с-компаратором">5. Двоичный поиск с
компаратором</h3>
<p><strong>带比较器的二分查找</strong></p>
<p>Используется, если нужно искать объекты (не числа/строки) или если
сортировка нестандартная.
当需要搜索对象（非数字/字符串）或排序非标准时使用。</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">people</span> <span class="op">=</span> listOf<span class="op">(</span>Person<span class="op">(</span><span class="st">&quot;Alice&quot;</span><span class="op">,</span> <span class="dv">20</span><span class="op">),</span> Person<span class="op">(</span><span class="st">&quot;Bob&quot;</span><span class="op">,</span> <span class="dv">30</span><span class="op">))</span> <span class="co">// Сортирован по возрасту (按年龄排序)</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Ищем человека с возрастом 30.</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 搜索年龄为 30 的人。</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">index</span> <span class="op">=</span> people<span class="op">.</span>binarySearch<span class="op">(</span>Person<span class="op">(</span><span class="st">&quot;Any&quot;</span><span class="op">,</span> <span class="dv">30</span><span class="op">),</span> Comparator <span class="op">{</span> p1<span class="op">,</span> p2 <span class="op">-&gt;</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>    p1<span class="op">.</span>age <span class="op">-</span> p2<span class="op">.</span>age</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span></code></pre></div>
<hr />
<h3 id="двоичный-поиск-с-функцией-сравнения">6. Двоичный поиск с
функцией сравнения</h3>
<p><strong>带比较函数的二分查找</strong></p>
<p>Самый гибкий способ. Вы передаете функцию, которая возвращает
<code>Int</code>:</p>
<ul>
<li><code>0</code>: Нашли.</li>
<li><code>&lt;0</code>: Искомое значение меньше текущего (искать
слева).</li>
<li><code>&gt;0</code>: Искомое значение больше текущего (искать
справа).</li>
</ul>
<p>最灵活的方式。传递一个返回 <code>Int</code> 的函数：</p>
<ul>
<li><code>0</code>: 找到了。</li>
<li><code>&lt;0</code>: 目标值小于当前值（向左搜）。</li>
<li><code>&gt;0</code>: 目标值大于当前值（向右搜）。</li>
</ul>
<div class="sourceCode" id="cb120"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">8</span><span class="op">)</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Ищем число 6.</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 搜索数字 6。</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">index</span> <span class="op">=</span> list<span class="op">.</span>binarySearch <span class="op">{</span> item <span class="op">-&gt;</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>    item<span class="op">.</span>compareTo<span class="op">(</span><span class="dv">6</span><span class="op">)</span> </span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="добавление-и-обновление">7. Добавление и обновление</h3>
<p><strong>添加和更新</strong></p>
<p>Возможно только в изменяемых списках (<code>MutableList</code>).
仅在可变列表 (<code>MutableList</code>) 中可用。</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> mutableListOf<span class="op">(</span><span class="st">&quot;One&quot;</span><span class="op">,</span> <span class="st">&quot;Two&quot;</span><span class="op">)</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Добавление в конец.</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 添加到末尾。</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>list<span class="op">.</span>add<span class="op">(</span><span class="st">&quot;Three&quot;</span><span class="op">)</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Вставка по индексу (сдвигает остальные элементы).</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 按索引插入（移动其他元素）。</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>list<span class="op">.</span>add<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="st">&quot;Zero&quot;</span><span class="op">)</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Обновление (замена) значения.</span></span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 更新（替换）值。</span></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a>list<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;Updated One&quot;</span></span></code></pre></div>
<hr />
<h3 id="удаление">8. Удаление</h3>
<p><strong>删除</strong></p>
<p>Возможно только в изменяемых списках (<code>MutableList</code>).
仅在可变列表 (<code>MutableList</code>) 中可用。</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> mutableListOf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="st">&quot;B&quot;</span><span class="op">,</span> <span class="st">&quot;C&quot;</span><span class="op">)</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Удаляет первый найденный элемент &quot;B&quot;.</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 删除找到的第一个元素 &quot;B&quot;。</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>list<span class="op">.</span>remove<span class="op">(</span><span class="st">&quot;B&quot;</span><span class="op">)</span> </span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Удаляет элемент по индексу 0.</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 删除索引为 0 的元素。</span></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>list<span class="op">.</span>removeAt<span class="op">(</span><span class="dv">0</span><span class="op">)</span></span></code></pre></div>
<hr />
<h3 id="сортировка">9. Сортировка</h3>
<p><strong>排序</strong></p>
<ul>
<li><code>sort()</code>: Сортирует <strong>текущий</strong> список
(только MutableList).</li>
<li><code>sorted()</code>: Создает <strong>новый</strong>
отсортированный список (для любых List).</li>
<li><code>sort()</code>: 对<strong>当前</strong>列表进行排序（仅限
MutableList）。</li>
<li><code>sorted()</code>:
创建一个排好序的<strong>新</strong>列表（适用于任何 List）。</li>
</ul>
<div class="sourceCode" id="cb123"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">numbers</span> <span class="op">=</span> mutableListOf<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Изменяет сам список numbers.</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 修改 numbers 列表本身。</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>numbers<span class="op">.</span>sort<span class="op">()</span> <span class="co">// [1, 2, 3]</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Сортировка по убыванию.</span></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 降序排序。</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a>numbers<span class="op">.</span>sortDescending<span class="op">()</span> <span class="co">// [3, 2, 1]</span></span></code></pre></div>
<h1
id="множества.-функции-union-intersect-и-subtract.-карты.-получение-ключей-и-значений.-фильтрация.-операции-и--.-добавление-и-обновление.-удаление.">16.
Множества. Функции union, intersect и subtract. Карты. Получение ключей
и значений. Фильтрация. Операции + и -. Добавление и обновление.
Удаление.</h1>
<p>Это <strong>16-й вопрос (Question 16)</strong>, посвященный операциям
над множествами (Set) и картами (Map) в Kotlin. 这是 <strong>第 16 题
(Question 16)</strong>，关于 Kotlin 中集合 (Set) 和映射 (Map)
的操作。</p>
<p>Мы разберем каждый пункт подробно без использования картинок.
我们将详细解析每一点，不使用图片。</p>
<hr />
<h3 id="множества-sets">1. Множества (Sets)</h3>
<p><strong>集合</strong></p>
<p>Коллекция, содержащая только уникальные элементы. Порядок элементов,
как правило, не гарантируется (кроме <code>LinkedHashSet</code>).
仅包含唯一元素的集合。通常不保证元素的顺序（<code>LinkedHashSet</code>
除外）。</p>
<hr />
<h3 id="функции-union-intersect-и-subtract">2. Функции union, intersect
и subtract</h3>
<p><strong>union, intersect 和 subtract 函数</strong></p>
<p>Это операции теории множеств, возвращающие <strong>новое</strong>
множество. 这是集合论操作，返回一个<strong>新</strong>集合。</p>
<ul>
<li><strong>union (Объединение / 并集):</strong> Элементы из обоих
множеств (уникальные).</li>
<li><strong>intersect (Пересечение / 交集):</strong> Только те элементы,
которые есть в <strong>обоих</strong> множествах.</li>
<li><strong>subtract (Разность / 差集):</strong> Элементы первого
множества, которых нет во втором.</li>
</ul>
<div class="sourceCode" id="cb124"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">set1</span> <span class="op">=</span> setOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">set2</span> <span class="op">=</span> setOf<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">)</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Объединение (1, 2, 3, 4, 5).</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 并集 (1, 2, 3, 4, 5)。</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">u</span> <span class="op">=</span> set1<span class="op">.</span>union<span class="op">(</span>set2<span class="op">)</span> <span class="co">// или set1 + set2</span></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Пересечение (3).</span></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 交集 (3)。</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">i</span> <span class="op">=</span> set1<span class="op">.</span>intersect<span class="op">(</span>set2<span class="op">)</span></span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Разность (1, 2). Убрали то, что есть в set2.</span></span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 差集 (1, 2)。移除了 set2 中存在的元素。</span></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">s</span> <span class="op">=</span> set1<span class="op">.</span>subtract<span class="op">(</span>set2<span class="op">)</span> <span class="co">// или set1 - set2</span></span></code></pre></div>
<hr />
<h3 id="карты-maps">3. Карты (Maps)</h3>
<p><strong>映射 (Maps)</strong></p>
<p>Карта (или словарь) хранит пары “Ключ-Значение”. Ключи уникальны.
映射（或字典）存储“键-值”对。键是唯一的。</p>
<hr />
<h3 id="получение-ключей-и-значений">4. Получение ключей и значений</h3>
<p><strong>获取键和值</strong></p>
<p>У карты есть свойства <code>keys</code> (возвращает Set ключей) и
<code>values</code> (возвращает Collection значений). Map 拥有
<code>keys</code> 属性（返回键的 Set）和 <code>values</code>
属性（返回值的 Collection）。</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">map</span> <span class="op">=</span> mapOf<span class="op">(</span><span class="st">&quot;A&quot;</span> to <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;B&quot;</span> to <span class="dv">2</span><span class="op">)</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Все ключи [&quot;A&quot;, &quot;B&quot;].</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 所有键 [&quot;A&quot;, &quot;B&quot;]。</span></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">allKeys</span> <span class="op">=</span> map<span class="op">.</span>keys</span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Все значения [1, 2].</span></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 所有值 [1, 2]。</span></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">allValues</span> <span class="op">=</span> map<span class="op">.</span>values</span></code></pre></div>
<hr />
<h3 id="фильтрация-filtering-maps">5. Фильтрация (Filtering Maps)</h3>
<p><strong>过滤</strong></p>
<p>Можно фильтровать карту по ключам, значениям или по самим записям
(entries). 可以按键、值或条目 (entries) 本身过滤 Map。</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">map</span> <span class="op">=</span> mapOf<span class="op">(</span><span class="st">&quot;Key1&quot;</span> to <span class="dv">10</span><span class="op">,</span> <span class="st">&quot;Key2&quot;</span> to <span class="dv">20</span><span class="op">)</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Оставить ключи, начинающиеся на &quot;K&quot;.</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 保留以 &quot;K&quot; 开头的键。</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">fKeys</span> <span class="op">=</span> map<span class="op">.</span>filterKeys <span class="op">{</span> it<span class="op">.</span>startsWith<span class="op">(</span><span class="st">&quot;K&quot;</span><span class="op">)</span> <span class="op">}</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Оставить значения больше 15.</span></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 保留大于 15 的值。</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">fValues</span> <span class="op">=</span> map<span class="op">.</span>filterValues <span class="op">{</span> it <span class="op">&gt;</span> <span class="dv">15</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="операции-и---map-operators">6. Операции + и - (Map
Operators)</h3>
<p><strong>+ 和 - 操作符</strong></p>
<p>Эти операторы создают <strong>новую</strong> карту, добавляя или
удаляя записи (не меняя исходную карту, даже если она read-only).
这些操作符创建<strong>新</strong> Map，添加或删除条目（不更改原始
Map，即使它是只读的）。</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">map</span> <span class="op">=</span> mapOf<span class="op">(</span><span class="st">&quot;A&quot;</span> to <span class="dv">1</span><span class="op">)</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Новая карта {A=1, B=2}.</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 新 Map {A=1, B=2}。</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">newMap</span> <span class="op">=</span> map <span class="op">+</span> <span class="op">(</span><span class="st">&quot;B&quot;</span> to <span class="dv">2</span><span class="op">)</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Новая карта без ключа &quot;A&quot;.</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 不包含键 &quot;A&quot; 的新 Map。</span></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">lessMap</span> <span class="op">=</span> newMap <span class="op">-</span> <span class="st">&quot;A&quot;</span></span></code></pre></div>
<hr />
<h3 id="добавление-и-обновление-1">7. Добавление и обновление</h3>
<p><strong>添加和更新</strong></p>
<p>Требуется <code>MutableMap</code>. Используется метод
<code>put</code> или индексатор <code>[]</code>. 需要
<code>MutableMap</code>。使用 <code>put</code> 方法或索引器
<code>[]</code>。</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">mutableMap</span> <span class="op">=</span> mutableMapOf<span class="op">(</span><span class="st">&quot;A&quot;</span> to <span class="dv">1</span><span class="op">)</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Добавление новой пары.</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 添加新对。</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>mutableMap<span class="op">[</span><span class="st">&quot;B&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span>  <span class="co">// mutableMap.put(&quot;B&quot;, 2)</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Обновление значения для существующего ключа.</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 更新现有键的值。</span></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>mutableMap<span class="op">[</span><span class="st">&quot;A&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">100</span></span></code></pre></div>
<hr />
<h3 id="удаление-1">8. Удаление</h3>
<p><strong>删除</strong></p>
<p>Требуется <code>MutableMap</code>. Используется метод
<code>remove(key)</code>. 需要 <code>MutableMap</code>。使用
<code>remove(key)</code> 方法。</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">mutableMap</span> <span class="op">=</span> mutableMapOf<span class="op">(</span><span class="st">&quot;A&quot;</span> to <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;B&quot;</span> to <span class="dv">2</span><span class="op">)</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Удаляет запись по ключу &quot;A&quot;.</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 按键 &quot;A&quot; 删除条目。</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>mutableMap<span class="op">.</span>remove<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">)</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Также можно через оператор -=.</span></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 也可以通过 -= 操作符。</span></span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a>mutableMap <span class="op">-=</span> <span class="st">&quot;B&quot;</span></span></code></pre></div>
<h1
id="последовательности-sequence.-отличие-коллекций-и-последовательностей.-порядок-обработки-элементов-в-коллекции.-порядок-обработки-элементов-в-последовательности.-последовательность.-промежуточная-и-завершающая-операции.-конструирование-последовательностей-из-элементов-и-итерируемых.-конструирование-последовательностей-из-функций.">17.
Последовательности (Sequence). Отличие коллекций и последовательностей.
Порядок обработки элементов в коллекции. Порядок обработки элементов в
последовательности. Последовательность. Промежуточная и завершающая
операции. Конструирование последовательностей из элементов и
итерируемых. Конструирование последовательностей из функций.</h1>
<p>Это <strong>17-й вопрос (Question 17)</strong>, посвященный
последовательностям (<code>Sequence</code>) в Kotlin. Это ключевая тема
для оптимизации производительности при работе с большими наборами
данных.</p>
<p>这是 <strong>第 17 题 (Question 17)</strong>，关于 Kotlin 中的序列
(<code>Sequence</code>)。这是优化大数据集处理性能的关键主题。</p>
<p>Мы разберем каждый пункт по порядку. (Без картинок, как вы просили).
我们将按顺序解析每一点。（按照您的要求，不含图片）。</p>
<hr />
<h3 id="последовательности-sequence">1. Последовательности
(Sequence)</h3>
<p><strong>序列</strong></p>
<p><code>Sequence</code> — это контейнер, который (в отличие от
<code>List</code>) не хранит элементы в памяти, а вычисляет их по одному
во время итерации. <code>Sequence</code> 是一个容器，与
<code>List</code>
不同，它不将元素存储在内存中，而是在迭代期间逐个计算它们。</p>
<hr />
<h3 id="отличие-коллекций-и-последовательностей">2. Отличие коллекций и
последовательностей</h3>
<p><strong>集合与序列的区别</strong></p>
<ul>
<li><strong>Коллекции (Iterable):</strong> “Жадные” (Eager). Выполняют
каждый шаг обработки сразу для <strong>всех</strong> элементов и создают
промежуточные списки.</li>
<li><strong>Последовательности (Sequence):</strong> “Ленивые” (Lazy).
Вычисляют элементы только тогда, когда они действительно нужны (в самом
конце).</li>
<li><strong>集合 (Iterable):</strong> “急切”
(Eager)。立即对<strong>所有</strong>元素执行每个处理步骤，并创建中间列表。</li>
<li><strong>序列 (Sequence):</strong> “懒惰”
(Lazy)。仅当真正需要元素时（在最后）才计算它们。</li>
</ul>
<hr />
<h3 id="порядок-обработки-элементов-в-коллекции">3. Порядок обработки
элементов в коллекции</h3>
<p><strong>集合中元素的处理顺序</strong></p>
<p>Обработка идет “горизонтально”. Сначала завершается операция A для
всего списка, затем операция B для всего списка.
处理是“水平”进行的。首先完成整个列表的操作 A，然后完成整个列表的操作
B。</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Сначала map создаст новый список [2, 4, 6].</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 首先 map 创建一个新列表 [2, 4, 6]。</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Затем filter создаст еще один список [4, 6].</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 然后 filter 创建另一个列表 [4, 6]。</span></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>list<span class="op">.</span>map <span class="op">{</span> it <span class="op">*</span> <span class="dv">2</span> <span class="op">}</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>filter <span class="op">{</span> it <span class="op">&gt;</span> <span class="dv">2</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="порядок-обработки-элементов-в-последовательности">4. Порядок
обработки элементов в последовательности</h3>
<p><strong>序列中元素的处理顺序</strong></p>
<p>Обработка идет “вертикально”. Первый элемент проходит через цепочку
операций (A -&gt; B), затем второй элемент (A -&gt; B) и т.д.
Промежуточные коллекции не создаются.
处理是“垂直”进行的。第一个元素通过操作链 (A -&gt; B)，然后是第二个元素
(A -&gt; B)，依此类推。不创建中间集合。</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Элемент 1 -&gt; map -&gt; filter.</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 元素 1 -&gt; map -&gt; filter.</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Элемент 2 -&gt; map -&gt; filter.</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 元素 2 -&gt; map -&gt; filter.</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>sequence<span class="op">.</span>map <span class="op">{</span> it <span class="op">*</span> <span class="dv">2</span> <span class="op">}.</span>filter <span class="op">{</span> it <span class="op">&gt;</span> <span class="dv">2</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="последовательность.-промежуточная-и-завершающая-операции.">5.
Последовательность. Промежуточная и завершающая операции.</h3>
<p><strong>序列。中间操作和末端操作</strong></p>
<p>Операции в <code>Sequence</code> делятся на два типа:</p>
<ol type="1">
<li><strong>Промежуточные (Intermediate):</strong> Возвращают новую
<code>Sequence</code> (например, <code>map</code>, <code>filter</code>).
Они <strong>не выполняются</strong> сразу.</li>
<li><strong>Завершающие (Terminal):</strong> Возвращают результат (List,
Int, Unit). Они <strong>запускают</strong> выполнение всей цепочки.</li>
</ol>
<p><code>Sequence</code> 中的操作分为两种类型：</p>
<ol type="1">
<li><strong>中间操作 (Intermediate):</strong> 返回新的
<code>Sequence</code>（例如 <code>map</code>,
<code>filter</code>）。它们<strong>不会立即执行</strong>。</li>
<li><strong>末端操作 (Terminal):</strong> 返回结果 (List, Int,
Unit)。它们<strong>触发</strong>整个链的执行。</li>
</ol>
<div class="sourceCode" id="cb132"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">seq</span> <span class="op">=</span> sequenceOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Ничего не происходит (лениво).</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 什么也没发生（懒惰）。</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">mapped</span> <span class="op">=</span> seq<span class="op">.</span>map <span class="op">{</span> println<span class="op">(</span>it<span class="op">);</span> it <span class="op">*</span> <span class="dv">2</span> <span class="op">}</span> </span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: toList() — терминальная операция. Только сейчас map запустится.</span></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: toList() 是末端操作。只有现在 map 才会运行。</span></span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">result</span> <span class="op">=</span> mapped<span class="op">.</span>toList<span class="op">()</span></span></code></pre></div>
<hr />
<h3
id="конструирование-последовательностей-из-элементов-и-итерируемых">6.
Конструирование последовательностей из элементов и итерируемых</h3>
<p><strong>从元素和可迭代对象构建序列</strong></p>
<p>Самый простой способ создать последовательность.
创建序列最简单的方法。</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 1. Из элементов (From elements)</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">s1</span> <span class="op">=</span> sequenceOf<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">)</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 2. Из коллекции (From collection)</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">list</span> <span class="op">=</span> listOf<span class="op">(</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">,</span> <span class="st">&quot;c&quot;</span><span class="op">)</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Превращаем &quot;тяжелый&quot; список в последовательность.</span></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 将“重”列表转换为序列。</span></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">s2</span> <span class="op">=</span> list<span class="op">.</span>asSequence<span class="op">()</span> </span></code></pre></div>
<hr />
<h3 id="конструирование-последовательностей-из-функций">7.
Конструирование последовательностей из функций</h3>
<p><strong>从函数构建序列</strong></p>
<p>Позволяет создавать <strong>бесконечные</strong> последовательности с
помощью <code>generateSequence</code>. 允许使用
<code>generateSequence</code> 创建<strong>无限</strong>序列。</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Первый элемент 1. Каждый следующий: предыдущий + 1.</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 第一个元素是 1。每一个后续元素：前一个 + 1。</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">naturalNumbers</span> <span class="op">=</span> generateSequence<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span> it <span class="op">+</span> <span class="dv">1</span> <span class="op">}</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Берем первые 5 элементов (иначе будет бесконечный цикл).</span></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 取前 5 个元素（否则会是无限循环）。</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">firstFive</span> <span class="op">=</span> naturalNumbers<span class="op">.</span>take<span class="op">(</span><span class="dv">5</span><span class="op">).</span>toList<span class="op">()</span> <span class="co">// [1, 2, 3, 4, 5]</span></span></code></pre></div>
<h1
id="делегирование-класса.-переопределение-члена-интерфейса-реализованного-делегированием.-доступ-к-реализациям-членов-интерфейса.-делегирование-свойств.-сигнатура-делегата.-действия-делегата.-ленивые-свойства.-обозреваемые-свойства.-хранение-свойств-в-ассоциативном-списке.">18.
Делегирование класса. Переопределение члена интерфейса, реализованного
делегированием. Доступ к реализациям членов интерфейса. Делегирование
свойств. Сигнатура делегата. Действия делегата. Ленивые свойства.
Обозреваемые свойства. Хранение свойств в ассоциативном списке.</h1>
<p>Это <strong>18-й вопрос (Question 18)</strong>, посвященный мощному
механизму делегирования в Kotlin. Это реализация паттерна “Delegation”
на уровне языка.</p>
<p>这是 <strong>第 18 题 (Question 18)</strong>，关于 Kotlin
中强大的委托机制。这是语言层面对“委托”模式的实现。</p>
<p>Мы разберем каждый пункт подробно (без картинок).
我们将详细解析每一点（不含图片）。</p>
<hr />
<h3 id="делегирование-класса">1. Делегирование класса</h3>
<p><strong>类委托</strong></p>
<p>Kotlin позволяет передать реализацию интерфейса другому объекту с
помощью ключевого слова <code>by</code>. Это альтернатива наследованию.
Kotlin 允许使用关键字 <code>by</code>
将接口的实现委托给另一个对象。这是继承的替代方案。</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Base <span class="op">{</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> <span class="fu">print</span><span class="op">()</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="fu">BaseImpl</span><span class="op">(</span><span class="kw">val</span> <span class="va">x</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> <span class="op">:</span> <span class="dt">Base</span> <span class="op">{</span></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">print</span><span class="op">()</span> <span class="op">=</span> print<span class="op">(</span>x<span class="op">)</span></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Derived делегирует реализацию интерфейса Base объекту b.</span></span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: Derived 将 Base 接口的实现委托给对象 b。</span></span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Derived<span class="op">(</span><span class="va">b</span><span class="op">:</span> <span class="dt">Base</span><span class="op">)</span> <span class="op">:</span> <span class="dt">Base</span> <span class="kw">by</span> b</span>
<span id="cb135-12"><a href="#cb135-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-13"><a href="#cb135-13" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">main</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb135-14"><a href="#cb135-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> <span class="va">b</span> <span class="op">=</span> BaseImpl<span class="op">(</span><span class="dv">10</span><span class="op">)</span></span>
<span id="cb135-15"><a href="#cb135-15" aria-hidden="true" tabindex="-1"></a>    Derived<span class="op">(</span>b<span class="op">).</span>print<span class="op">()</span> <span class="co">// Output: 10</span></span>
<span id="cb135-16"><a href="#cb135-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3
id="переопределение-члена-интерфейса-реализованного-делегированием">2.
Переопределение члена интерфейса, реализованного делегированием</h3>
<p><strong>重写通过委托实现的接口成员</strong></p>
<p>Даже если класс делегирует реализацию, он может переопределить методы
самостоятельно. Собственная реализация имеет приоритет.
即使类委托了实现，它也可以自己重写方法。自己的实现具有优先级。</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Derived<span class="op">(</span><span class="va">b</span><span class="op">:</span> <span class="dt">Base</span><span class="op">)</span> <span class="op">:</span> <span class="dt">Base</span> <span class="kw">by</span> b <span class="op">{</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Переопределяем метод. Делегат (b.print) вызван не будет.</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 重写方法。委托 (b.print) 不会被调用。</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">print</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Override&quot;</span><span class="op">)</span></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="доступ-к-реализациям-членов-интерфейса">3. Доступ к реализациям
членов интерфейса</h3>
<p><strong>访问接口成员的实现</strong></p>
<p>Если вы переопределили метод, вы <strong>не можете</strong> вызвать
реализацию делегата через <code>super</code>. Чтобы иметь к ней доступ,
нужно сохранить делегат в свойстве класса.
如果您重写了方法，您<strong>不能</strong>通过 <code>super</code>
调用委托的实现。要访问它，必须将委托保存在类属性中。</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Сохраняем &#39;b&#39; как private val, чтобы обращаться к нему.</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 将 &#39;b&#39; 保存为 private val，以便访问它。</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Derived<span class="op">(</span><span class="kw">private</span> <span class="kw">val</span> <span class="va">b</span><span class="op">:</span> <span class="dt">Base</span><span class="op">)</span> <span class="op">:</span> <span class="dt">Base</span> <span class="kw">by</span> b <span class="op">{</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">print</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// super.print() // Error!</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>        b<span class="op">.</span>print<span class="op">()</span> <span class="co">// OK</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Additional logic&quot;</span><span class="op">)</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="делегирование-свойств">4. Делегирование свойств</h3>
<p><strong>属性委托</strong></p>
<p>Позволяет перенести логику геттеров и сеттеров в отдельный класс.
Синтаксис: <code>val/var &lt;имя&gt; by &lt;делегат&gt;</code>. 允许将
Getter 和 Setter
的逻辑移至单独的类中。语法：<code>val/var &lt;名称&gt; by &lt;委托&gt;</code>。</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Example <span class="op">{</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Логика чтения/записи &#39;p&#39; находится в классе Delegate.</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: &#39;p&#39; 的读/写逻辑位于 Delegate 类中。</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> <span class="va">p</span><span class="op">:</span> <span class="kw">String</span> <span class="kw">by</span> Delegate<span class="op">()</span></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="сигнатура-делегата">5. Сигнатура делегата</h3>
<p><strong>委托签名</strong></p>
<p>Класс-делегат должен иметь методы <code>getValue</code> (и
<code>setValue</code> для var) с оператором <code>operator</code>.
委托类必须具有带有 <code>operator</code> 操作符的 <code>getValue</code>
方法（对于 var 还需要 <code>setValue</code>）。</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">kotlin</span><span class="op">.</span><span class="im">reflect</span><span class="op">.</span><span class="im">KProperty</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Delegate <span class="op">{</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Метод для чтения (get).</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 读取方法 (get)。</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">getValue</span><span class="op">(</span><span class="va">thisRef</span><span class="op">:</span> <span class="dt">Any</span><span class="op">?,</span> <span class="va">property</span><span class="op">:</span> <span class="dt">KProperty</span>&lt;*&gt;<span class="op">):</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="st">&quot;Delegate value&quot;</span></span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Метод для записи (set) - нужен только для var.</span></span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 写入方法 (set) - 仅 var 需要。</span></span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">setValue</span><span class="op">(</span><span class="va">thisRef</span><span class="op">:</span> <span class="dt">Any</span><span class="op">?,</span> <span class="va">property</span><span class="op">:</span> <span class="dt">KProperty</span>&lt;*&gt;<span class="op">,</span> <span class="va">value</span><span class="op">:</span> <span class="dt">String</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb139-13"><a href="#cb139-13" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;Assigned: </span><span class="ss">$value</span><span class="st">&quot;</span><span class="op">)</span></span>
<span id="cb139-14"><a href="#cb139-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb139-15"><a href="#cb139-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="действия-делегата">6. Действия делегата</h3>
<p><strong>委托操作</strong></p>
<p>Внутри методов <code>getValue</code> и <code>setValue</code> можно
выполнять любые действия: логирование, проверку данных, чтение из базы и
т.д. 在 <code>getValue</code> 和 <code>setValue</code>
方法内部，可以执行任何操作：记录日志、数据验证、从数据库读取等。</p>
<hr />
<h3 id="ленивые-свойства-lazy-properties">7. Ленивые свойства (Lazy
Properties)</h3>
<p><strong>延迟属性 (Lazy Properties)</strong></p>
<p>Стандартный делегат <code>lazy</code>. Значение вычисляется только
при первом обращении и запоминается. 标准委托
<code>lazy</code>。值仅在第一次访问时计算并被记住。</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Вычисление произойдет только при первом вызове lazyValue.</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 只有在第一次调用 lazyValue 时才会进行计算。</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">lazyValue</span><span class="op">:</span> <span class="kw">String</span> <span class="kw">by</span> lazy <span class="op">{</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;Computed!&quot;</span><span class="op">)</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Hello&quot;</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="обозреваемые-свойства-observable-properties">8. Обозреваемые
свойства (Observable Properties)</h3>
<p><strong>可观察属性</strong></p>
<p>Стандартный делегат <code>Delegates.observable</code>. Позволяет
выполнить код при каждом изменении свойства. 标准委托
<code>Delegates.observable</code>。允许在每次属性更改时执行代码。</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">kotlin</span><span class="op">.</span><span class="im">properties</span><span class="op">.</span><span class="im">Delegates</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> User <span class="op">{</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Лямбда вызывается после каждого присваивания.</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 每次赋值后都会调用 Lambda。</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> <span class="va">name</span><span class="op">:</span> <span class="kw">String</span> <span class="kw">by</span> Delegates<span class="op">.</span>observable<span class="op">(</span><span class="st">&quot;No Name&quot;</span><span class="op">)</span> <span class="op">{</span> prop<span class="op">,</span> old<span class="op">,</span> new <span class="op">-&gt;</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a>        println<span class="op">(</span><span class="st">&quot;</span><span class="ss">$old</span><span class="st"> -&gt; </span><span class="ss">$new</span><span class="st">&quot;</span><span class="op">)</span></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3
id="хранение-свойств-в-ассоциативном-списке-storing-properties-in-a-map">9.
Хранение свойств в ассоциативном списке (Storing properties in a
Map)</h3>
<p><strong>在映射 (Map) 中存储属性</strong></p>
<p>Можно использовать <code>Map</code> как делегат. Это удобно для
парсинга JSON или динамических конфигураций. 可以使用 <code>Map</code>
作为委托。这对解析 JSON 或动态配置非常方便。</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> User<span class="op">(</span><span class="kw">val</span> <span class="va">map</span><span class="op">:</span> <span class="dt">Map</span>&lt;<span class="va">String</span><span class="op">,</span> <span class="va">Any</span>?&gt;<span class="op">)</span> <span class="op">{</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Значение берется из карты по ключу &quot;name&quot;.</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 值从 Map 中按键 &quot;name&quot; 获取。</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> <span class="va">name</span><span class="op">:</span> <span class="kw">String</span> <span class="kw">by</span> map</span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">val</span> <span class="va">age</span><span class="op">:</span> <span class="kw">Int</span>     <span class="kw">by</span> map</span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">user</span> <span class="op">=</span> User<span class="op">(</span>mapOf<span class="op">(</span></span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;name&quot;</span> to <span class="st">&quot;John&quot;</span><span class="op">,</span></span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;age&quot;</span>  to <span class="dv">25</span></span>
<span id="cb142-11"><a href="#cb142-11" aria-hidden="true" tabindex="-1"></a><span class="op">))</span></span></code></pre></div>
<h1
id="внутренний-dsl.-синтаксические-особенности-языка-kotlin-для-создания-dsl.-функция-расширение.-инфиксный-вызов-функции.-перегрузка-операторов.-соглашение-о-методе-getset.-лямбда-выражение-вне-круглых-скобок.-псевдонимы-типа.-мульти-декларации.-html-построитель.-json-построитель.">19.
Внутренний DSL. Синтаксические особенности языка Kotlin для создания
DSL. Функция-расширение. Инфиксный вызов функции. Перегрузка операторов.
Соглашение о методе get/set. Лямбда-выражение вне круглых скобок.
Псевдонимы типа. Мульти-декларации. HTML-построитель.
JSON-построитель.</h1>
<p>Это <strong>19-й вопрос (Question 19)</strong>, посвященный созданию
<strong>DSL (Domain Specific Languages)</strong> в Kotlin. Это одна из
самых продвинутых и интересных тем языка.</p>
<p>这是 <strong>第 19 题 (Question 19)</strong>，关于在 Kotlin 中创建
<strong>DSL（领域特定语言）</strong>。这是该语言最高级和最有趣的主题之一。</p>
<p>Мы разберем каждый пункт подробно. 我们将详细解析每一点。</p>
<hr />
<h3 id="внутренний-dsl-internal-dsl">1. Внутренний DSL (Internal
DSL)</h3>
<p><strong>内部 DSL</strong></p>
<p>Внутренний DSL — это язык, созданный с использованием синтаксиса
основного языка (Kotlin) для решения специфических задач (например,
построение HTML, конфигурация Gradle, SQL-запросы). 内部 DSL
是使用主语言 (Kotlin) 的语法创建的语言，用于解决特定任务（例如构建
HTML、Gradle 配置、SQL 查询）。</p>
<hr />
<h3 id="синтаксические-особенности-языка-kotlin-для-создания-dsl">2.
Синтаксические особенности языка Kotlin для создания DSL</h3>
<p><strong>用于创建 DSL 的 Kotlin 语法特性</strong></p>
<p>Kotlin обладает набором функций, которые позволяют убрать
“синтаксический шум” (скобки, точки, запятые), делая код похожим на
естественный язык или структуру данных. Kotlin
拥有一套特性，允许消除“语法噪音”（括号、点、逗号），使代码看起来像自然语言或数据结构。</p>
<hr />
<h3 id="функция-расширение-extension-function">3. Функция-расширение
(Extension Function)</h3>
<p><strong>扩展函数</strong></p>
<p>Позволяет добавлять методы в существующие классы. В DSL это
используется для добавления функций-тегов (например, <code>body</code>,
<code>div</code>) в контекст построителя. 允许向现有类添加方法。在 DSL
中，这用于向构建器上下文中添加标签函数（例如 <code>body</code>,
<code>div</code>）。</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Добавляем функцию div в класс HTML.</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 向 HTML 类添加 div 函数。</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">HTML</span><span class="op">.</span><span class="fu">div</span><span class="op">(</span><span class="va">block</span><span class="op">:</span> <span class="dt">DIV</span>.(<span class="op">)</span> -&gt; <span class="fu">Unit</span>) <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="инфиксный-вызов-функции-infix-call">4. Инфиксный вызов функции
(Infix Call)</h3>
<p><strong>中缀函数调用</strong></p>
<p>Позволяет вызывать функцию без точки и круглых скобок, если у нее
один аргумент. Это делает код похожим на предложение.
如果函数只有一个参数，则允许在没有点和圆括号的情况下调用它。这使代码看起来像一个句子。</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infix</span> <span class="kw">fun</span> <span class="fu">String</span><span class="op">.</span><span class="fu">shouldBe</span><span class="op">(</span><span class="va">expected</span><span class="op">:</span> <span class="dt">String</span><span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Вызов как в английском языке.</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 像英语一样调用。</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Result&quot;</span> shouldBe <span class="st">&quot;Result&quot;</span> </span></code></pre></div>
<hr />
<h3 id="перегрузка-операторов-operator-overloading-1">5. Перегрузка
операторов (Operator Overloading)</h3>
<p><strong>操作符重载</strong></p>
<p>Позволяет использовать знаки <code>+</code>, <code>-</code>,
<code>*</code> для своих типов. В DSL часто используется унарный плюс
<code>+</code> для добавления строк или оператор <code>invoke</code>
<code>()</code>. 允许对自己定义的类型使用符号 <code>+</code>,
<code>-</code>, <code>*</code>。在 DSL 中，常使用一元加号 <code>+</code>
来添加字符串，或使用 <code>invoke</code> <code>()</code> 操作符。</p>
<div class="sourceCode" id="cb145"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">String</span><span class="op">.</span><span class="fu">unaryPlus</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// RU: Логика добавления строки в тег.</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CN: 将字符串添加到标签的逻辑。</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>html <span class="op">{</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span><span class="st">&quot;This is text inside tag&quot;</span></span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="соглашение-о-методе-getset">6. Соглашение о методе get/set</h3>
<p><strong>get/set 方法约定</strong></p>
<p>Если определить операторы <code>get</code> и <code>set</code>, можно
использовать квадратные скобки <code>[]</code>. Это удобно для настройки
маппингов или доступа к элементам. 如果定义了 <code>get</code> 和
<code>set</code> 操作符，则可以使用方括号
<code>[]</code>。这对配置映射或访问元素非常方便。</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="co">// DSL для конфигурации</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>config<span class="op">[</span><span class="st">&quot;port&quot;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">8080</span> <span class="co">// Вызывает config.set(&quot;port&quot;, 8080)</span></span></code></pre></div>
<hr />
<h3 id="лямбда-выражение-вне-круглых-скобок-trailing-lambda">7.
Лямбда-выражение вне круглых скобок (Trailing Lambda)</h3>
<p><strong>圆括号外的 Lambda 表达式</strong></p>
<p>Самая важная фича для DSL. Если лямбда — последний аргумент, она
пишется <code>{ }</code> вместо <code>({ })</code>. Это позволяет
создавать вложенные структуры. DSL 最重要的特性。如果 Lambda
是最后一个参数，则写成 <code>{ }</code> 而不是
<code>({ })</code>。这允许创建嵌套结构。</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Вместо html({ body({ ... }) })</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 代替 html({ body({ ... }) })</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>html <span class="op">{</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>    body <span class="op">{</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>        div <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="псевдонимы-типа-type-aliases">8. Псевдонимы типа (Type
Aliases)</h3>
<p><strong>类型别名</strong></p>
<p>Позволяют дать понятное имя функциональному типу или сложному
дженерику, улучшая читаемость DSL.
允许给函数类型或复杂的泛型起一个易懂的名字，提高 DSL 的可读性。</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typealias</span> ElementInit <span class="op">=</span> Element<span class="op">.()</span> <span class="op">-&gt;</span> <span class="kw">Unit</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">body</span><span class="op">(</span><span class="va">init</span><span class="op">:</span> <span class="dt">ElementInit</span><span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="мульти-декларации-destructuring-declarations">9.
Мульти-декларации (Destructuring Declarations)</h3>
<p><strong>多重声明（解构声明）</strong></p>
<p>Позволяют разложить объект на переменные. В DSL используется в циклах
по картам. 允许将对象分解为变量。在 DSL 中用于遍历 Map。</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">map</span> <span class="op">=</span> mapOf<span class="op">(</span><span class="dv">1</span> to <span class="st">&quot;A&quot;</span><span class="op">,</span> <span class="dv">2</span> to <span class="st">&quot;B&quot;</span><span class="op">)</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Разлагаем запись карты на ключ и значение.</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 将 Map 条目分解为键和值。</span></span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">((</span>key<span class="op">,</span> value<span class="op">)</span> <span class="kw">in</span> map<span class="op">)</span> <span class="op">{</span></span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;</span><span class="ss">$key</span><span class="st"> -&gt; </span><span class="ss">$value</span><span class="st">&quot;</span><span class="op">)</span></span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="html-построитель-html-builder">10. HTML-построитель (HTML
Builder)</h3>
<p><strong>HTML 构建器</strong></p>
<p>Классический пример Kotlin DSL. Это типобезопасный способ генерации
HTML-кода (библиотека <code>kotlinx.html</code>). Kotlin DSL
的经典示例。这是生成 HTML 代码的类型安全方式（<code>kotlinx.html</code>
库）。</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">myHtml</span> <span class="op">=</span> html <span class="op">{</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>    body <span class="op">{</span></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>        div <span class="op">{</span></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>            a<span class="op">(</span>href <span class="op">=</span> <span class="st">&quot;https://kotlinlang.org&quot;</span><span class="op">)</span> <span class="op">{</span> <span class="op">+</span><span class="st">&quot;Kotlin&quot;</span> <span class="op">}</span></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="json-построитель-json-builder">11. JSON-построитель (JSON
Builder)</h3>
<p><strong>JSON 构建器</strong></p>
<p>Аналогичный подход для создания JSON-структур. Выглядит чище, чем
создание строк вручную. 创建 JSON
结构的类似方法。看起来比手动创建字符串更干净。</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">json</span> <span class="op">=</span> json <span class="op">{</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;name&quot;</span> to <span class="st">&quot;John&quot;</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;age&quot;</span> to <span class="dv">30</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;contacts&quot;</span> to jsonArray <span class="op">{</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span><span class="st">&quot;email@example.com&quot;</span></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span><span class="st">&quot;phone number&quot;</span></span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1
id="совместное-использование-языков-kotlin-и-java.-вызов-кода-java-из-kotlin.-геттеры-и-сеттеры.-экранирование-идентификаторов-java.-нулевые-ссылки-из-java.-аннотации-допустимости-null-значений.-родовые-типы-java-в-kotlin.-массивы-java-в-kotlin.-методы-java-с-переменным-числом-параметров.">20.
Совместное использование языков Kotlin и Java. Вызов кода Java из
Kotlin. Геттеры и сеттеры. Экранирование идентификаторов Java. Нулевые
ссылки из Java. Аннотации допустимости null значений. Родовые типы Java
в Kotlin. Массивы Java в Kotlin. Методы Java с переменным числом
параметров.</h1>
<p>Это <strong>20-й вопрос (Question 20)</strong>, посвященный
совместимости Kotlin и Java (Interoperability). Это одна из главных
причин успеха Kotlin — вы можете использовать старый Java-код в новом
проекте на Kotlin без проблем.</p>
<p>这是 <strong>第 20 题 (Question 20)</strong>，关于 Kotlin 和 Java
的互操作性 (Interoperability)。这是 Kotlin 成功的主要原因之一 ——
您可以在新的 Kotlin 项目中毫无问题地使用旧的 Java 代码。</p>
<p>Мы разберем каждый пункт подробно. 我们将详细解析每一点。</p>
<hr />
<h3 id="совместное-использование-языков-kotlin-и-java">1. Совместное
использование языков Kotlin и Java</h3>
<p><strong>Kotlin 和 Java 的共同使用</strong></p>
<p>Kotlin спроектирован так, чтобы быть на 100% совместимым с Java. Они
оба компилируются в байт-код JVM. Вы можете иметь файлы
<code>.java</code> и <code>.kt</code> в одном проекте. Kotlin 被设计为与
Java 100% 兼容。它们都编译为 JVM 字节码。您可以在同一个项目中同时拥有
<code>.java</code> 和 <code>.kt</code> 文件。</p>
<hr />
<h3 id="вызов-кода-java-из-kotlin">2. Вызов кода Java из Kotlin</h3>
<p><strong>从 Kotlin 调用 Java 代码</strong></p>
<p>Классы Java можно создавать и использовать так же, как классы Kotlin.
<code>new</code> писать не нужно. 可以像 Kotlin 类一样创建和使用 Java
类。不需要写 <code>new</code>。</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java: public class JavaUser { ... }</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Kotlin:</span></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Создаем экземпляр Java-класса.</span></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 创建 Java 类的实例。</span></span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">user</span> <span class="op">=</span> java<span class="op">.</span>util<span class="op">.</span>ArrayList<span class="op">&lt;</span><span class="kw">String</span><span class="op">&gt;()</span> </span>
<span id="cb152-7"><a href="#cb152-7" aria-hidden="true" tabindex="-1"></a>user<span class="op">.</span>add<span class="op">(</span><span class="st">&quot;Item&quot;</span><span class="op">)</span></span></code></pre></div>
<hr />
<h3 id="геттеры-и-сеттеры-getters-and-setters">3. Геттеры и сеттеры
(Getters and Setters)</h3>
<p><strong>Getter 和 Setter</strong></p>
<p>Методы Java, следующие конвенции JavaBeans
(<code>getSomething</code>, <code>setSomething</code>), в Kotlin видны
как <strong>свойства</strong>. 遵循 JavaBeans 约定
(<code>getSomething</code>, <code>setSomething</code>) 的 Java 方法在
Kotlin 中被视为<strong>属性</strong>。</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Java:</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="co">   public String getName() { ... }</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a><span class="co">   public void setName(String name) { ... }</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Kotlin:</span></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Вместо user.getName()</span></span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 代替 user.getName()</span></span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span>user<span class="op">.</span>name<span class="op">)</span> </span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Вместо user.setName(&quot;Alice&quot;)</span></span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 代替 user.setName(&quot;Alice&quot;)</span></span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a>user<span class="op">.</span>name <span class="op">=</span> <span class="st">&quot;Alice&quot;</span> </span></code></pre></div>
<hr />
<h3 id="экранирование-идентификаторов-java">4. Экранирование
идентификаторов Java</h3>
<p><strong>Java 标识符转义</strong></p>
<p>Если имя метода в Java совпадает с ключевым словом в Kotlin
(например, <code>in</code>, <code>is</code>, <code>object</code>), его
нужно заключить в обратные кавычки
<code>. 如果 Java 中的方法名与 Kotlin 中的关键字（例如 `in`, `is`, `object`）冲突，则需要将其包含在反引号</code>
中。</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java: public void is() { ... }</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Kotlin:</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Экранируем имя метода.</span></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 转义方法名。</span></span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a>javaObject<span class="op">.</span>`is`<span class="op">()</span></span></code></pre></div>
<hr />
<h3 id="нулевые-ссылки-из-java-platform-types">5. Нулевые ссылки из Java
(Platform Types)</h3>
<p><strong>来自 Java 的空引用（平台类型）</strong></p>
<p>Если в Java типе нет аннотаций
(<code>@Nullable</code>/<code>@NotNull</code>), Kotlin не знает, может
ли он быть null. Такой тип называется <strong>Платформенным
типом</strong> (<code>String!</code>). 如果 Java 类型没有注解
(<code>@Nullable</code>/<code>@NotNull</code>)，Kotlin
不知道它是否可以是 null。这种类型被称为<strong>平台类型</strong>
(<code>String!</code>)。</p>
<ul>
<li>Вы можете работать с ним как с <code>String</code> (риск
<code>NullPointerException</code>).</li>
<li>Вы можете работать с ним как с <code>String?</code>
(безопасно).</li>
<li>您可以将其视为 <code>String</code> 处理（有
<code>NullPointerException</code> 风险）。</li>
<li>您可以将其视为 <code>String?</code> 处理（安全）。</li>
</ul>
<hr />
<h3 id="аннотации-допустимости-null-значений">6. Аннотации допустимости
null значений</h3>
<p><strong>空值允许注解</strong></p>
<p>Kotlin понимает стандартные аннотации Java (из
<code>javax.annotation</code>, <code>org.jetbrains.annotations</code>,
<code>android.support.annotation</code> и т.д.). Kotlin 理解标准的 Java
注解（来自 <code>javax.annotation</code>,
<code>org.jetbrains.annotations</code>,
<code>android.support.annotation</code> 等）。</p>
<ul>
<li>Java <code>@Nullable String</code> -&gt; Kotlin
<code>String?</code></li>
<li>Java <code>@NotNull String</code> -&gt; Kotlin
<code>String</code></li>
</ul>
<hr />
<h3 id="родовые-типы-java-в-kotlin">7. Родовые типы Java в Kotlin</h3>
<p><strong>Kotlin 中的 Java 泛型</strong></p>
<p>Генерики Java преобразуются в генерики Kotlin. Java Wildcards
(<code>? extends</code>) преобразуются в <code>out</code> и
<code>in</code> (site-variance). Java 泛型转换为 Kotlin 泛型。Java
通配符 (<code>? extends</code>) 转换为 <code>out</code> 和
<code>in</code> (site-variance)。</p>
<ul>
<li><code>List&lt;? extends String&gt;</code> -&gt;
<code>List&lt;out String&gt;</code></li>
<li><code>List&lt;? super String&gt;</code> -&gt;
<code>List&lt;in String&gt;</code></li>
<li><code>List</code> (raw type) -&gt; <code>List&lt;*&gt;</code>!</li>
</ul>
<hr />
<h3 id="массивы-java-в-kotlin">8. Массивы Java в Kotlin</h3>
<p><strong>Kotlin 中的 Java 数组</strong></p>
<p>Массивы в Kotlin инвариантны (в отличие от Java). Примитивные массивы
Java (<code>int[]</code>) отображаются в специальные классы
(<code>IntArray</code>). Kotlin 中的数组是不变的（与 Java 不同）。Java
的原始数组 (<code>int[]</code>) 映射到特殊的类
(<code>IntArray</code>)。</p>
<ul>
<li>Java <code>int[]</code> -&gt; Kotlin <code>IntArray</code></li>
<li>Java <code>String[]</code> -&gt; Kotlin
<code>Array&lt;String&gt;</code></li>
</ul>
<div class="sourceCode" id="cb155"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java: public void process(int[] data);</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Kotlin:</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">data</span> <span class="op">=</span> IntArray<span class="op">(</span><span class="dv">5</span><span class="op">)</span></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>javaObj<span class="op">.</span>process<span class="op">(</span><span class="kw">data</span><span class="op">)</span></span></code></pre></div>
<hr />
<h3 id="методы-java-с-переменным-числом-параметров-varargs">9. Методы
Java с переменным числом параметров (Varargs)</h3>
<p><strong>带可变参数的 Java 方法</strong></p>
<p>Чтобы передать массив в Java-метод, принимающий <code>varargs</code>
(<code>...</code>), в Kotlin нужно использовать оператор разыменования
(spread operator) <code>*</code>. 要将数组传递给接收
<code>varargs</code> (<code>...</code>) 的 Java 方法，需要在 Kotlin
中使用展开操作符 <code>*</code>。</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java: void log(String... lines);</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="va">lines</span> <span class="op">=</span> arrayOf<span class="op">(</span><span class="st">&quot;Line 1&quot;</span><span class="op">,</span> <span class="st">&quot;Line 2&quot;</span><span class="op">)</span></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Звездочка обязательна!</span></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 星号是必须的！</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>javaLog<span class="op">.</span>log<span class="op">(*</span>lines<span class="op">)</span></span></code></pre></div>
<h1
id="совместное-использование-языков-kotlin-и-java.-вызов-кода-kotlin-из-java.-свойства.-функции-уровня-пакета.-смена-имени-генерируемого-java-класса.-поля-экземпляра.-статические-поля.-статические-методы.">21.
Совместное использование языков Kotlin и Java. Вызов кода Kotlin из
Java. Свойства. Функции уровня пакета. Смена имени генерируемого Java
класса. Поля экземпляра. Статические поля. Статические методы.</h1>
<p>Это <strong>21-й вопрос (Question 21)</strong>, посвященный обратной
стороне совместимости: как Java видит код, написанный на Kotlin.</p>
<p>这是 <strong>第 21 题 (Question
21)</strong>，关于互操作性的另一方面：Java 如何看待用 Kotlin
编写的代码。</p>
<p>Мы разберем каждый пункт подробно без картинок.
我们将详细解析每一点，不使用图片。</p>
<hr />
<h3
id="совместное-использование-языков-kotlin-и-java.-вызов-кода-kotlin-из-java.">1.
Совместное использование языков Kotlin и Java. Вызов кода Kotlin из
Java.</h3>
<p><strong>Kotlin 和 Java 的共同使用。从 Java 调用 Kotlin
代码。</strong></p>
<p>Kotlin компилируется в стандартный байт-код JVM. Для Java классы
Kotlin выглядят как обычные Java-классы, но есть нюансы с именованием и
статикой. Kotlin 编译为标准的 JVM 字节码。对于 Java 而言，Kotlin
类看起来像普通的 Java 类，但在命名和静态方面存在细微差别。</p>
<hr />
<h3 id="свойства-properties">2. Свойства (Properties)</h3>
<p><strong>属性</strong></p>
<p>Свойства Kotlin (<code>val</code>/<code>var</code>) компилируются в
приватное поле + геттер/сеттер. Kotlin 属性
(<code>val</code>/<code>var</code>) 编译为私有字段 + Getter/Setter。</p>
<ul>
<li><code>val x: Int</code> -&gt; <code>int getX()</code></li>
<li><code>var y: Int</code> -&gt; <code>int getY()</code>,
<code>void setY(int value)</code></li>
<li><code>isBool: Boolean</code> -&gt; <code>boolean isBool()</code>,
<code>void setBool(boolean value)</code></li>
</ul>
<div class="sourceCode" id="cb157"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java code:</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>MyClass obj <span class="op">=</span> <span class="kw">new</span> <span class="fu">MyClass</span><span class="op">();</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Вызываем геттер, который сгенерировал Kotlin.</span></span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 调用 Kotlin 生成的 Getter。</span></span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> name <span class="op">=</span> obj<span class="op">.</span><span class="fu">getName</span><span class="op">();</span> </span></code></pre></div>
<hr />
<h3 id="функции-уровня-пакета-package-level-functions">3. Функции уровня
пакета (Package-level functions)</h3>
<p><strong>包级函数</strong></p>
<p>Функции, объявленные в файле вне класса (top-level), компилируются в
статические методы класса с именем файла + суффикс <code>Kt</code>.
在类外部（顶层）声明的函数编译为文件名为名 + 后缀 <code>Kt</code>
的类的静态方法。</p>
<ul>
<li>Файл <code>Utils.kt</code> -&gt; Класс <code>UtilsKt</code></li>
</ul>
<div class="sourceCode" id="cb158"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Utils.kt</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">doWork</span><span class="op">()</span> <span class="op">{}</span></span></code></pre></div>
<div class="sourceCode" id="cb159"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java code:</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Обращаемся через имя файла + Kt.</span></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 通过文件名 + Kt 访问。</span></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>UtilsKt<span class="op">.</span><span class="fu">doWork</span><span class="op">();</span></span></code></pre></div>
<hr />
<h3 id="смена-имени-генерируемого-java-класса">4. Смена имени
генерируемого Java класса</h3>
<p><strong>更改生成的 Java 类名</strong></p>
<p>Если имя <code>UtilsKt</code> вам не нравится, его можно изменить с
помощью аннотации <code>@file:JvmName</code>, размещенной в самом начале
файла. 如果您不喜欢 <code>UtilsKt</code>
这个名字，可以使用放置在文件开头的注解 <code>@file:JvmName</code>
来更改它。</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Utils.kt</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a><span class="at">@file</span><span class="op">:</span><span class="at">JvmName</span><span class="op">(</span><span class="st">&quot;Helper&quot;</span><span class="op">)</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> <span class="im">com</span><span class="op">.</span><span class="im">example</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> <span class="fu">doWork</span><span class="op">()</span> <span class="op">{}</span></span></code></pre></div>
<div class="sourceCode" id="cb161"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java code:</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Теперь имя класса чистое.</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 现在类名很干净。</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>Helper<span class="op">.</span><span class="fu">doWork</span><span class="op">();</span></span></code></pre></div>
<hr />
<h3 id="поля-экземпляра-instance-fields">5. Поля экземпляра (Instance
Fields)</h3>
<p><strong>实例字段</strong></p>
<p>Если вам нужно, чтобы свойство Kotlin было обычным публичным полем
Java (без геттеров/сеттеров), используйте аннотацию
<code>@JvmField</code>. 如果您需要 Kotlin 属性成为普通的 Java
公共字段（无 Getter/Setter），请使用 <code>@JvmField</code> 注解。</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> User <span class="op">{</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">@JvmField</span></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> <span class="va">id</span><span class="op">:</span> <span class="kw">Int</span> <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb163"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java code:</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>User u <span class="op">=</span> <span class="kw">new</span> <span class="fu">User</span><span class="op">();</span></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Прямой доступ к полю, как в Java (u.id).</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a><span class="co">// CN:像 Java 一样直接访问字段 (u.id)。</span></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>u<span class="op">.</span><span class="fu">id</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> </span></code></pre></div>
<hr />
<h3 id="статические-поля-static-fields">6. Статические поля (Static
Fields)</h3>
<p><strong>静态字段</strong></p>
<p>В Kotlin нет <code>static</code>. Статические поля создаются двумя
способами:</p>
<ol type="1">
<li><code>const val</code> (в <code>companion object</code> или
top-level): становится <code>public static final</code>.</li>
<li><code>@JvmField</code> внутри <code>object</code>: становится
<code>public static</code>.</li>
</ol>
<p>Kotlin 中没有 <code>static</code>。静态字段通过两种方式创建：</p>
<ol type="1">
<li><code>const val</code>（在 <code>companion object</code>
或顶层中）：变为 <code>public static final</code>。</li>
<li><code>object</code> 内部的 <code>@JvmField</code>：变为
<code>public static</code>。</li>
</ol>
<div class="sourceCode" id="cb164"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> Config <span class="op">{</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> <span class="kw">val</span> <span class="va">VERSION</span> <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">@JvmField</span> <span class="kw">val</span> <span class="va">URL</span> <span class="op">=</span> <span class="st">&quot;http&quot;</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb165"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java:</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v <span class="op">=</span> Config<span class="op">.</span><span class="fu">VERSION</span><span class="op">;</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> u <span class="op">=</span> Config<span class="op">.</span><span class="fu">URL</span><span class="op">;</span></span></code></pre></div>
<hr />
<h3 id="статические-методы-static-methods">7. Статические методы (Static
Methods)</h3>
<p><strong>静态方法</strong></p>
<p>Методы внутри <code>object</code> или <code>companion object</code>
по умолчанию <strong>не</strong> являются статическими в Java (они
вызываются через <code>INSTANCE</code>). Чтобы сделать их настоящими
<code>static</code> методами, нужна аннотация <code>@JvmStatic</code>.
<code>object</code> 或 <code>companion object</code> 内部的方法在 Java
中默认<strong>不</strong>是静态的（它们通过 <code>INSTANCE</code>
调用）。要使它们成为真正的 <code>static</code> 方法，需要
<code>@JvmStatic</code> 注解。</p>
<div class="sourceCode" id="cb166"><pre
class="sourceCode kotlin"><code class="sourceCode kotlin"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> KeyGenerator <span class="op">{</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">companion</span> <span class="kw">object</span> <span class="op">{</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">@JvmStatic</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fun</span> <span class="fu">generate</span><span class="op">():</span> <span class="dt">String</span> <span class="op">=</span> <span class="st">&quot;Key&quot;</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb167"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java:</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Работает как обычный статический метод.</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 像普通的静态方法一样工作。</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> key <span class="op">=</span> <span class="bu">KeyGenerator</span><span class="op">.</span><span class="fu">generate</span><span class="op">();</span></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a><span class="co">// RU: Без @JvmStatic пришлось бы писать: KeyGenerator.Companion.generate()</span></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a><span class="co">// CN: 没有 @JvmStatic 则必须写成：KeyGenerator.Companion.generate()</span></span></code></pre></div>
</body>
</html>
